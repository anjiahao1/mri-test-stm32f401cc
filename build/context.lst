ARM GAS  /tmp/ccj5sP08.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"context.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "mri/core/context.c"
  20              		.section	.text.writeBytesToBufferAsHex,"ax",%progbits
  21              		.align	1
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	writeBytesToBufferAsHex:
  27              	.LVL0:
  28              	.LFB8:
   1:mri/core/context.c **** /* Copyright 2020 Adam Green (https://github.com/adamgreen/)
   2:mri/core/context.c **** 
   3:mri/core/context.c ****    Licensed under the Apache License, Version 2.0 (the "License");
   4:mri/core/context.c ****    you may not use this file except in compliance with the License.
   5:mri/core/context.c ****    You may obtain a copy of the License at
   6:mri/core/context.c **** 
   7:mri/core/context.c ****        http://www.apache.org/licenses/LICENSE-2.0
   8:mri/core/context.c **** 
   9:mri/core/context.c ****    Unless required by applicable law or agreed to in writing, software
  10:mri/core/context.c ****    distributed under the License is distributed on an "AS IS" BASIS,
  11:mri/core/context.c ****    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  12:mri/core/context.c ****    See the License for the specific language governing permissions and
  13:mri/core/context.c ****    limitations under the License.
  14:mri/core/context.c **** */
  15:mri/core/context.c **** /*  'Class' which represents a scatter gather list of registers so that blocks of them can be pulle
  16:mri/core/context.c ****     locations on the stack and they don't all need to be placed in one contiguous place in memory.
  17:mri/core/context.c **** */
  18:mri/core/context.c **** #include <core/context.h>
  19:mri/core/context.c **** #include <core/try_catch.h>
  20:mri/core/context.c **** 
  21:mri/core/context.c **** 
  22:mri/core/context.c **** void Context_Init(MriContext* pThis, ContextSection* pSections, uint32_t sectionCount)
  23:mri/core/context.c **** {
  24:mri/core/context.c ****     pThis->pSections = pSections;
  25:mri/core/context.c ****     pThis->sectionCount = sectionCount;
  26:mri/core/context.c **** }
  27:mri/core/context.c **** 
  28:mri/core/context.c **** uint32_t Context_Count(MriContext* pThis)
  29:mri/core/context.c **** {
  30:mri/core/context.c ****     uint32_t i;
ARM GAS  /tmp/ccj5sP08.s 			page 2


  31:mri/core/context.c ****     uint32_t count = 0;
  32:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
  33:mri/core/context.c ****     {
  34:mri/core/context.c ****         count += pThis->pSections[i].count;
  35:mri/core/context.c ****     }
  36:mri/core/context.c ****     return count;
  37:mri/core/context.c **** }
  38:mri/core/context.c **** 
  39:mri/core/context.c **** uint32_t Context_Get(const MriContext* pThis, uint32_t index)
  40:mri/core/context.c **** {
  41:mri/core/context.c ****     uint32_t i;
  42:mri/core/context.c ****     uint32_t count = 0;
  43:mri/core/context.c ****     uint32_t base = 0;
  44:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
  45:mri/core/context.c ****     {
  46:mri/core/context.c ****         base = count;
  47:mri/core/context.c ****         count += pThis->pSections[i].count;
  48:mri/core/context.c ****         if (index < count)
  49:mri/core/context.c ****         {
  50:mri/core/context.c ****             return pThis->pSections[i].pValues[index - base];
  51:mri/core/context.c ****         }
  52:mri/core/context.c ****     }
  53:mri/core/context.c ****     __throw_and_return(bufferOverrunException, 0);
  54:mri/core/context.c **** }
  55:mri/core/context.c **** 
  56:mri/core/context.c **** void Context_Set(MriContext* pThis, uint32_t index, uint32_t newValue)
  57:mri/core/context.c **** {
  58:mri/core/context.c ****     uint32_t i;
  59:mri/core/context.c ****     uint32_t count = 0;
  60:mri/core/context.c ****     uint32_t base = 0;
  61:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
  62:mri/core/context.c ****     {
  63:mri/core/context.c ****         base = count;
  64:mri/core/context.c ****         count += pThis->pSections[i].count;
  65:mri/core/context.c ****         if (index < count)
  66:mri/core/context.c ****         {
  67:mri/core/context.c ****             pThis->pSections[i].pValues[index - base] = newValue;
  68:mri/core/context.c ****             return;
  69:mri/core/context.c ****         }
  70:mri/core/context.c ****     }
  71:mri/core/context.c ****     __throw(bufferOverrunException);
  72:mri/core/context.c **** }
  73:mri/core/context.c **** 
  74:mri/core/context.c **** 
  75:mri/core/context.c **** static void writeBytesToBufferAsHex(Buffer* pBuffer, void* pBytes, size_t byteCount);
  76:mri/core/context.c **** void Context_CopyToBuffer(MriContext* pThis, Buffer* pBuffer)
  77:mri/core/context.c **** {
  78:mri/core/context.c ****     uint32_t count = Context_Count(pThis);
  79:mri/core/context.c ****     uint32_t i;
  80:mri/core/context.c **** 
  81:mri/core/context.c ****     for (i = 0 ; i < count ; i++)
  82:mri/core/context.c ****     {
  83:mri/core/context.c ****         uint32_t reg = Context_Get(pThis, i);
  84:mri/core/context.c ****         writeBytesToBufferAsHex(pBuffer, &reg, sizeof(reg));
  85:mri/core/context.c ****     }
  86:mri/core/context.c **** }
  87:mri/core/context.c **** 
ARM GAS  /tmp/ccj5sP08.s 			page 3


  88:mri/core/context.c **** static void writeBytesToBufferAsHex(Buffer* pBuffer, void* pBytes, size_t byteCount)
  89:mri/core/context.c **** {
  29              		.loc 1 89 1 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		.loc 1 89 1 is_stmt 0 view .LVU1
  34 0000 70B5     		push	{r4, r5, r6, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 16
  37              		.cfi_offset 4, -16
  38              		.cfi_offset 5, -12
  39              		.cfi_offset 6, -8
  40              		.cfi_offset 14, -4
  41 0002 0646     		mov	r6, r0
  42 0004 0C46     		mov	r4, r1
  90:mri/core/context.c ****     uint8_t* pByte = (uint8_t*)pBytes;
  43              		.loc 1 90 5 is_stmt 1 view .LVU2
  44              	.LVL1:
  91:mri/core/context.c ****     while (byteCount--)
  45              		.loc 1 91 5 view .LVU3
  46              		.loc 1 91 11 is_stmt 0 view .LVU4
  47 0006 05E0     		b	.L2
  48              	.LVL2:
  49              	.L3:
  92:mri/core/context.c ****         Buffer_WriteByteAsHex(pBuffer, *pByte++);
  50              		.loc 1 92 9 is_stmt 1 view .LVU5
  51              		.loc 1 92 9 is_stmt 0 view .LVU6
  52 0008 14F8011B 		ldrb	r1, [r4], #1	@ zero_extendqisi2
  53              	.LVL3:
  54              		.loc 1 92 9 view .LVU7
  55 000c 3046     		mov	r0, r6
  56 000e FFF7FEFF 		bl	mriBuffer_WriteByteAsHex
  57              	.LVL4:
  91:mri/core/context.c ****     while (byteCount--)
  58              		.loc 1 91 21 view .LVU8
  59 0012 2A46     		mov	r2, r5
  60              	.LVL5:
  61              	.L2:
  91:mri/core/context.c ****     while (byteCount--)
  62              		.loc 1 91 12 is_stmt 1 view .LVU9
  91:mri/core/context.c ****     while (byteCount--)
  63              		.loc 1 91 21 is_stmt 0 view .LVU10
  64 0014 551E     		subs	r5, r2, #1
  65              	.LVL6:
  91:mri/core/context.c ****     while (byteCount--)
  66              		.loc 1 91 12 view .LVU11
  67 0016 002A     		cmp	r2, #0
  68 0018 F6D1     		bne	.L3
  93:mri/core/context.c **** }
  69              		.loc 1 93 1 view .LVU12
  70 001a 70BD     		pop	{r4, r5, r6, pc}
  71              		.loc 1 93 1 view .LVU13
  72              		.cfi_endproc
  73              	.LFE8:
  75              		.section	.text.readBytesFromBufferAsHex,"ax",%progbits
  76              		.align	1
ARM GAS  /tmp/ccj5sP08.s 			page 4


  77              		.syntax unified
  78              		.thumb
  79              		.thumb_func
  81              	readBytesFromBufferAsHex:
  82              	.LVL7:
  83              	.LFB10:
  94:mri/core/context.c **** 
  95:mri/core/context.c **** 
  96:mri/core/context.c **** static void readBytesFromBufferAsHex(Buffer* pBuffer, void* pBytes, size_t byteCount);
  97:mri/core/context.c **** void Context_CopyFromBuffer(MriContext* pThis, Buffer* pBuffer)
  98:mri/core/context.c **** {
  99:mri/core/context.c ****     uint32_t count = Context_Count(pThis);
 100:mri/core/context.c ****     uint32_t i;
 101:mri/core/context.c **** 
 102:mri/core/context.c ****     for (i = 0 ; i < count ; i++) {
 103:mri/core/context.c ****         uint32_t reg;
 104:mri/core/context.c ****         readBytesFromBufferAsHex(pBuffer, &reg, sizeof(reg));
 105:mri/core/context.c ****         Context_Set(pThis, i, reg);
 106:mri/core/context.c ****     }
 107:mri/core/context.c **** }
 108:mri/core/context.c **** 
 109:mri/core/context.c **** static void readBytesFromBufferAsHex(Buffer* pBuffer, void* pBytes, size_t byteCount)
 110:mri/core/context.c **** {
  84              		.loc 1 110 1 is_stmt 1 view -0
  85              		.cfi_startproc
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
  88              		.loc 1 110 1 is_stmt 0 view .LVU15
  89 0000 70B5     		push	{r4, r5, r6, lr}
  90              	.LCFI1:
  91              		.cfi_def_cfa_offset 16
  92              		.cfi_offset 4, -16
  93              		.cfi_offset 5, -12
  94              		.cfi_offset 6, -8
  95              		.cfi_offset 14, -4
  96 0002 0646     		mov	r6, r0
  97 0004 0C46     		mov	r4, r1
 111:mri/core/context.c ****     uint8_t* pByte = (uint8_t*)pBytes;
  98              		.loc 1 111 5 is_stmt 1 view .LVU16
  99              	.LVL8:
 112:mri/core/context.c ****     while (byteCount--)
 100              		.loc 1 112 5 view .LVU17
 101              		.loc 1 112 11 is_stmt 0 view .LVU18
 102 0006 05E0     		b	.L6
 103              	.LVL9:
 104              	.L7:
 113:mri/core/context.c ****         *pByte++ = Buffer_ReadByteAsHex(pBuffer);
 105              		.loc 1 113 9 is_stmt 1 view .LVU19
 106              		.loc 1 113 20 is_stmt 0 view .LVU20
 107 0008 3046     		mov	r0, r6
 108 000a FFF7FEFF 		bl	mriBuffer_ReadByteAsHex
 109              	.LVL10:
 110              		.loc 1 113 18 view .LVU21
 111 000e 04F8010B 		strb	r0, [r4], #1
 112              	.LVL11:
 112:mri/core/context.c ****     while (byteCount--)
 113              		.loc 1 112 21 view .LVU22
ARM GAS  /tmp/ccj5sP08.s 			page 5


 114 0012 2A46     		mov	r2, r5
 115              	.LVL12:
 116              	.L6:
 112:mri/core/context.c ****     while (byteCount--)
 117              		.loc 1 112 12 is_stmt 1 view .LVU23
 112:mri/core/context.c ****     while (byteCount--)
 118              		.loc 1 112 21 is_stmt 0 view .LVU24
 119 0014 551E     		subs	r5, r2, #1
 120              	.LVL13:
 112:mri/core/context.c ****     while (byteCount--)
 121              		.loc 1 112 12 view .LVU25
 122 0016 002A     		cmp	r2, #0
 123 0018 F6D1     		bne	.L7
 114:mri/core/context.c **** }...
 124              		.loc 1 114 1 view .LVU26
 125 001a 70BD     		pop	{r4, r5, r6, pc}
 126              		.loc 1 114 1 view .LVU27
 127              		.cfi_endproc
 128              	.LFE10:
 130              		.section	.text.mriContext_Init,"ax",%progbits
 131              		.align	1
 132              		.global	mriContext_Init
 133              		.syntax unified
 134              		.thumb
 135              		.thumb_func
 137              	mriContext_Init:
 138              	.LVL14:
 139              	.LFB3:
  23:mri/core/context.c **** {
 140              		.loc 1 23 1 is_stmt 1 view -0
 141              		.cfi_startproc
 142              		@ args = 0, pretend = 0, frame = 0
 143              		@ frame_needed = 0, uses_anonymous_args = 0
 144              		@ link register save eliminated.
  24:mri/core/context.c ****     pThis->pSections = pSections;
 145              		.loc 1 24 5 view .LVU29
  24:mri/core/context.c ****     pThis->pSections = pSections;
 146              		.loc 1 24 22 is_stmt 0 view .LVU30
 147 0000 0160     		str	r1, [r0]
  25:mri/core/context.c ****     pThis->sectionCount = sectionCount;
 148              		.loc 1 25 5 is_stmt 1 view .LVU31
  25:mri/core/context.c ****     pThis->sectionCount = sectionCount;
 149              		.loc 1 25 25 is_stmt 0 view .LVU32
 150 0002 4260     		str	r2, [r0, #4]
  26:mri/core/context.c **** }
 151              		.loc 1 26 1 view .LVU33
 152 0004 7047     		bx	lr
 153              		.cfi_endproc
 154              	.LFE3:
 156              		.section	.text.mriContext_Count,"ax",%progbits
 157              		.align	1
 158              		.global	mriContext_Count
 159              		.syntax unified
 160              		.thumb
 161              		.thumb_func
 163              	mriContext_Count:
 164              	.LVL15:
ARM GAS  /tmp/ccj5sP08.s 			page 6


 165              	.LFB4:
  29:mri/core/context.c **** {
 166              		.loc 1 29 1 is_stmt 1 view -0
 167              		.cfi_startproc
 168              		@ args = 0, pretend = 0, frame = 0
 169              		@ frame_needed = 0, uses_anonymous_args = 0
 170              		@ link register save eliminated.
  29:mri/core/context.c **** {
 171              		.loc 1 29 1 is_stmt 0 view .LVU35
 172 0000 0146     		mov	r1, r0
  30:mri/core/context.c ****     uint32_t i;
 173              		.loc 1 30 5 is_stmt 1 view .LVU36
  31:mri/core/context.c ****     uint32_t count = 0;
 174              		.loc 1 31 5 view .LVU37
 175              	.LVL16:
  32:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 176              		.loc 1 32 5 view .LVU38
  31:mri/core/context.c ****     uint32_t count = 0;
 177              		.loc 1 31 14 is_stmt 0 view .LVU39
 178 0002 0020     		movs	r0, #0
 179              	.LVL17:
  32:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 180              		.loc 1 32 12 view .LVU40
 181 0004 0346     		mov	r3, r0
  32:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 182              		.loc 1 32 5 view .LVU41
 183 0006 05E0     		b	.L11
 184              	.LVL18:
 185              	.L12:
  34:mri/core/context.c ****         count += pThis->pSections[i].count;
 186              		.loc 1 34 9 is_stmt 1 discriminator 3 view .LVU42
  34:mri/core/context.c ****         count += pThis->pSections[i].count;
 187              		.loc 1 34 23 is_stmt 0 discriminator 3 view .LVU43
 188 0008 0A68     		ldr	r2, [r1]
  34:mri/core/context.c ****         count += pThis->pSections[i].count;
 189              		.loc 1 34 34 discriminator 3 view .LVU44
 190 000a 02EBC302 		add	r2, r2, r3, lsl #3
  34:mri/core/context.c ****         count += pThis->pSections[i].count;
 191              		.loc 1 34 37 discriminator 3 view .LVU45
 192 000e 5268     		ldr	r2, [r2, #4]
  34:mri/core/context.c ****         count += pThis->pSections[i].count;
 193              		.loc 1 34 15 discriminator 3 view .LVU46
 194 0010 1044     		add	r0, r0, r2
 195              	.LVL19:
  32:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 196              		.loc 1 32 45 is_stmt 1 discriminator 3 view .LVU47
 197 0012 0133     		adds	r3, r3, #1
 198              	.LVL20:
 199              	.L11:
  32:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 200              		.loc 1 32 20 discriminator 1 view .LVU48
  32:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 201              		.loc 1 32 27 is_stmt 0 discriminator 1 view .LVU49
 202 0014 4A68     		ldr	r2, [r1, #4]
  32:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 203              		.loc 1 32 20 discriminator 1 view .LVU50
 204 0016 9A42     		cmp	r2, r3
ARM GAS  /tmp/ccj5sP08.s 			page 7


 205 0018 F6D8     		bhi	.L12
  36:mri/core/context.c ****     return count;
 206              		.loc 1 36 5 is_stmt 1 view .LVU51
  37:mri/core/context.c **** }
 207              		.loc 1 37 1 is_stmt 0 view .LVU52
 208 001a 7047     		bx	lr
 209              		.cfi_endproc
 210              	.LFE4:
 212              		.section	.text.mriContext_Get,"ax",%progbits
 213              		.align	1
 214              		.global	mriContext_Get
 215              		.syntax unified
 216              		.thumb
 217              		.thumb_func
 219              	mriContext_Get:
 220              	.LVL21:
 221              	.LFB5:
  40:mri/core/context.c **** {
 222              		.loc 1 40 1 is_stmt 1 view -0
 223              		.cfi_startproc
 224              		@ args = 0, pretend = 0, frame = 0
 225              		@ frame_needed = 0, uses_anonymous_args = 0
 226              		@ link register save eliminated.
  40:mri/core/context.c **** {
 227              		.loc 1 40 1 is_stmt 0 view .LVU54
 228 0000 10B4     		push	{r4}
 229              	.LCFI2:
 230              		.cfi_def_cfa_offset 4
 231              		.cfi_offset 4, -4
  41:mri/core/context.c ****     uint32_t i;
 232              		.loc 1 41 5 is_stmt 1 view .LVU55
  42:mri/core/context.c ****     uint32_t count = 0;
 233              		.loc 1 42 5 view .LVU56
 234              	.LVL22:
  43:mri/core/context.c ****     uint32_t base = 0;
 235              		.loc 1 43 5 view .LVU57
  44:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 236              		.loc 1 44 5 view .LVU58
  42:mri/core/context.c ****     uint32_t count = 0;
 237              		.loc 1 42 14 is_stmt 0 view .LVU59
 238 0002 4FF0000C 		mov	ip, #0
  44:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 239              		.loc 1 44 12 view .LVU60
 240 0006 6246     		mov	r2, ip
  44:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 241              		.loc 1 44 5 view .LVU61
 242 0008 01E0     		b	.L14
 243              	.LVL23:
 244              	.L15:
  44:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 245              		.loc 1 44 45 is_stmt 1 discriminator 2 view .LVU62
 246 000a 0132     		adds	r2, r2, #1
 247              	.LVL24:
  47:mri/core/context.c ****         count += pThis->pSections[i].count;
 248              		.loc 1 47 15 is_stmt 0 discriminator 2 view .LVU63
 249 000c 9C46     		mov	ip, r3
 250              	.LVL25:
ARM GAS  /tmp/ccj5sP08.s 			page 8


 251              	.L14:
  44:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 252              		.loc 1 44 20 is_stmt 1 discriminator 1 view .LVU64
  44:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 253              		.loc 1 44 27 is_stmt 0 discriminator 1 view .LVU65
 254 000e 4368     		ldr	r3, [r0, #4]
  44:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 255              		.loc 1 44 20 discriminator 1 view .LVU66
 256 0010 9342     		cmp	r3, r2
 257 0012 0DD9     		bls	.L19
  46:mri/core/context.c ****         base = count;
 258              		.loc 1 46 9 is_stmt 1 view .LVU67
 259              	.LVL26:
  47:mri/core/context.c ****         count += pThis->pSections[i].count;
 260              		.loc 1 47 9 view .LVU68
  47:mri/core/context.c ****         count += pThis->pSections[i].count;
 261              		.loc 1 47 23 is_stmt 0 view .LVU69
 262 0014 0468     		ldr	r4, [r0]
  47:mri/core/context.c ****         count += pThis->pSections[i].count;
 263              		.loc 1 47 34 view .LVU70
 264 0016 04EBC203 		add	r3, r4, r2, lsl #3
  47:mri/core/context.c ****         count += pThis->pSections[i].count;
 265              		.loc 1 47 37 view .LVU71
 266 001a 5B68     		ldr	r3, [r3, #4]
  47:mri/core/context.c ****         count += pThis->pSections[i].count;
 267              		.loc 1 47 15 view .LVU72
 268 001c 6344     		add	r3, r3, ip
 269              	.LVL27:
  48:mri/core/context.c ****         if (index < count)
 270              		.loc 1 48 9 is_stmt 1 view .LVU73
  48:mri/core/context.c ****         if (index < count)
 271              		.loc 1 48 12 is_stmt 0 view .LVU74
 272 001e 8B42     		cmp	r3, r1
 273 0020 F3D9     		bls	.L15
  50:mri/core/context.c ****             return pThis->pSections[i].pValues[index - base];
 274              		.loc 1 50 13 is_stmt 1 view .LVU75
  50:mri/core/context.c ****             return pThis->pSections[i].pValues[index - base];
 275              		.loc 1 50 39 is_stmt 0 view .LVU76
 276 0022 54F83230 		ldr	r3, [r4, r2, lsl #3]
 277              	.LVL28:
  50:mri/core/context.c ****             return pThis->pSections[i].pValues[index - base];
 278              		.loc 1 50 54 view .LVU77
 279 0026 A1EB0C01 		sub	r1, r1, ip
 280              	.LVL29:
  50:mri/core/context.c ****             return pThis->pSections[i].pValues[index - base];
 281              		.loc 1 50 47 view .LVU78
 282 002a 53F82100 		ldr	r0, [r3, r1, lsl #2]
 283              	.LVL30:
  50:mri/core/context.c ****             return pThis->pSections[i].pValues[index - base];
 284              		.loc 1 50 47 view .LVU79
 285 002e 06E0     		b	.L13
 286              	.LVL31:
 287              	.L19:
  53:mri/core/context.c ****     __throw_and_return(bufferOverrunException, 0);
 288              		.loc 1 53 5 is_stmt 1 view .LVU80
 289              	.LBB6:
 290              	.LBI6:
ARM GAS  /tmp/ccj5sP08.s 			page 9


 291              		.file 2 "mri/core/try_catch.h"
   1:mri/core/try_catch.h **** /* Copyright 2014 Adam Green (https://github.com/adamgreen/)
   2:mri/core/try_catch.h **** 
   3:mri/core/try_catch.h ****    Licensed under the Apache License, Version 2.0 (the "License");
   4:mri/core/try_catch.h ****    you may not use this file except in compliance with the License.
   5:mri/core/try_catch.h ****    You may obtain a copy of the License at
   6:mri/core/try_catch.h **** 
   7:mri/core/try_catch.h ****        http://www.apache.org/licenses/LICENSE-2.0
   8:mri/core/try_catch.h **** 
   9:mri/core/try_catch.h ****    Unless required by applicable law or agreed to in writing, software
  10:mri/core/try_catch.h ****    distributed under the License is distributed on an "AS IS" BASIS,
  11:mri/core/try_catch.h ****    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  12:mri/core/try_catch.h ****    See the License for the specific language governing permissions and
  13:mri/core/try_catch.h ****    limitations under the License.
  14:mri/core/try_catch.h **** */
  15:mri/core/try_catch.h **** /* Very rough exception handling like macros for C. */
  16:mri/core/try_catch.h **** #ifndef MRI_TRY_CATCH_H_
  17:mri/core/try_catch.h **** #define MRI_TRY_CATCH_H_
  18:mri/core/try_catch.h **** 
  19:mri/core/try_catch.h **** #define noException                         0
  20:mri/core/try_catch.h **** #define bufferOverrunException              1
  21:mri/core/try_catch.h **** #define invalidHexDigitException            2
  22:mri/core/try_catch.h **** #define invalidValueException               3
  23:mri/core/try_catch.h **** #define invalidArgumentException            4
  24:mri/core/try_catch.h **** #define timeoutException                    5
  25:mri/core/try_catch.h **** #define invalidIndexException               6
  26:mri/core/try_catch.h **** #define notFoundException                   7
  27:mri/core/try_catch.h **** #define exceededHardwareResourcesException  8
  28:mri/core/try_catch.h **** #define invalidDecDigitException            9
  29:mri/core/try_catch.h **** #define memFaultException                   10
  30:mri/core/try_catch.h **** #define mriMaxException                     15
  31:mri/core/try_catch.h **** 
  32:mri/core/try_catch.h **** extern int mriExceptionCode;
  33:mri/core/try_catch.h **** 
  34:mri/core/try_catch.h **** 
  35:mri/core/try_catch.h **** /* Allow an application including MRI to extend with their own exception codes and replace the belo
  36:mri/core/try_catch.h **** #ifndef MRI_SKIP_TRY_CATCH_MACRO_DEFINES
  37:mri/core/try_catch.h **** 
  38:mri/core/try_catch.h **** /* On Linux, it is possible that __try and __catch are already defined. */
  39:mri/core/try_catch.h **** #undef __try
  40:mri/core/try_catch.h **** #undef __catch
  41:mri/core/try_catch.h **** 
  42:mri/core/try_catch.h **** #define __throws
  43:mri/core/try_catch.h **** 
  44:mri/core/try_catch.h **** #define __try \
  45:mri/core/try_catch.h ****         do \
  46:mri/core/try_catch.h ****         { \
  47:mri/core/try_catch.h ****             clearExceptionCode();
  48:mri/core/try_catch.h **** 
  49:mri/core/try_catch.h **** #define __throwing_func(X) \
  50:mri/core/try_catch.h ****             X; \
  51:mri/core/try_catch.h ****             if (mriExceptionCode) \
  52:mri/core/try_catch.h ****                 break;
  53:mri/core/try_catch.h **** 
  54:mri/core/try_catch.h **** #define __catch \
  55:mri/core/try_catch.h ****         } while (0); \
  56:mri/core/try_catch.h ****         if (mriExceptionCode)
ARM GAS  /tmp/ccj5sP08.s 			page 10


  57:mri/core/try_catch.h **** 
  58:mri/core/try_catch.h **** #define __throw(EXCEPTION) return ((void)setExceptionCode(EXCEPTION))
  59:mri/core/try_catch.h **** 
  60:mri/core/try_catch.h **** #define __throw_and_return(EXCEPTION, RETURN) return (setExceptionCode(EXCEPTION), (RETURN))
  61:mri/core/try_catch.h **** 
  62:mri/core/try_catch.h **** #define __rethrow return
  63:mri/core/try_catch.h **** 
  64:mri/core/try_catch.h **** #define __rethrow_and_return(RETURN) return RETURN
  65:mri/core/try_catch.h **** 
  66:mri/core/try_catch.h **** static inline int getExceptionCode(void)
  67:mri/core/try_catch.h **** {
  68:mri/core/try_catch.h ****     return mriExceptionCode;
  69:mri/core/try_catch.h **** }
  70:mri/core/try_catch.h **** 
  71:mri/core/try_catch.h **** static inline void setExceptionCode(int exceptionCode)
 292              		.loc 2 71 20 view .LVU81
 293              	.LBB7:
  72:mri/core/try_catch.h **** {
  73:mri/core/try_catch.h ****     mriExceptionCode = exceptionCode > mriExceptionCode ? exceptionCode : mriExceptionCode;
 294              		.loc 2 73 5 view .LVU82
 295              		.loc 2 73 73 is_stmt 0 view .LVU83
 296 0030 044A     		ldr	r2, .L20
 297              	.LVL32:
 298              		.loc 2 73 73 view .LVU84
 299 0032 1368     		ldr	r3, [r2]
 300 0034 012B     		cmp	r3, #1
 301 0036 B8BF     		it	lt
 302 0038 0123     		movlt	r3, #1
 303              		.loc 2 73 22 view .LVU85
 304 003a 1360     		str	r3, [r2]
 305              	.LVL33:
 306              		.loc 2 73 22 view .LVU86
 307              	.LBE7:
 308              	.LBE6:
  53:mri/core/context.c ****     __throw_and_return(bufferOverrunException, 0);
 309              		.loc 1 53 5 view .LVU87
 310 003c 0020     		movs	r0, #0
 311              	.LVL34:
 312              	.L13:
  54:mri/core/context.c **** }
 313              		.loc 1 54 1 view .LVU88
 314 003e 5DF8044B 		ldr	r4, [sp], #4
 315              	.LCFI3:
 316              		.cfi_restore 4
 317              		.cfi_def_cfa_offset 0
 318 0042 7047     		bx	lr
 319              	.L21:
 320              		.align	2
 321              	.L20:
 322 0044 00000000 		.word	mriExceptionCode
 323              		.cfi_endproc
 324              	.LFE5:
 326              		.section	.text.mriContext_Set,"ax",%progbits
 327              		.align	1
 328              		.global	mriContext_Set
 329              		.syntax unified
 330              		.thumb
ARM GAS  /tmp/ccj5sP08.s 			page 11


 331              		.thumb_func
 333              	mriContext_Set:
 334              	.LVL35:
 335              	.LFB6:
  57:mri/core/context.c **** {
 336              		.loc 1 57 1 is_stmt 1 view -0
 337              		.cfi_startproc
 338              		@ args = 0, pretend = 0, frame = 0
 339              		@ frame_needed = 0, uses_anonymous_args = 0
  57:mri/core/context.c **** {
 340              		.loc 1 57 1 is_stmt 0 view .LVU90
 341 0000 10B5     		push	{r4, lr}
 342              	.LCFI4:
 343              		.cfi_def_cfa_offset 8
 344              		.cfi_offset 4, -8
 345              		.cfi_offset 14, -4
  58:mri/core/context.c ****     uint32_t i;
 346              		.loc 1 58 5 is_stmt 1 view .LVU91
  59:mri/core/context.c ****     uint32_t count = 0;
 347              		.loc 1 59 5 view .LVU92
 348              	.LVL36:
  60:mri/core/context.c ****     uint32_t base = 0;
 349              		.loc 1 60 5 view .LVU93
  61:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 350              		.loc 1 61 5 view .LVU94
  59:mri/core/context.c ****     uint32_t count = 0;
 351              		.loc 1 59 14 is_stmt 0 view .LVU95
 352 0002 4FF0000E 		mov	lr, #0
  61:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 353              		.loc 1 61 12 view .LVU96
 354 0006 F446     		mov	ip, lr
  61:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 355              		.loc 1 61 5 view .LVU97
 356 0008 02E0     		b	.L23
 357              	.LVL37:
 358              	.L24:
  61:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 359              		.loc 1 61 45 is_stmt 1 discriminator 2 view .LVU98
 360 000a 0CF1010C 		add	ip, ip, #1
 361              	.LVL38:
  64:mri/core/context.c ****         count += pThis->pSections[i].count;
 362              		.loc 1 64 15 is_stmt 0 discriminator 2 view .LVU99
 363 000e 9E46     		mov	lr, r3
 364              	.LVL39:
 365              	.L23:
  61:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 366              		.loc 1 61 20 is_stmt 1 discriminator 1 view .LVU100
  61:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 367              		.loc 1 61 27 is_stmt 0 discriminator 1 view .LVU101
 368 0010 4368     		ldr	r3, [r0, #4]
  61:mri/core/context.c ****     for (i = 0 ; i < pThis->sectionCount ; i++)
 369              		.loc 1 61 20 discriminator 1 view .LVU102
 370 0012 6345     		cmp	r3, ip
 371 0014 0DD9     		bls	.L28
  63:mri/core/context.c ****         base = count;
 372              		.loc 1 63 9 is_stmt 1 view .LVU103
 373              	.LVL40:
ARM GAS  /tmp/ccj5sP08.s 			page 12


  64:mri/core/context.c ****         count += pThis->pSections[i].count;
 374              		.loc 1 64 9 view .LVU104
  64:mri/core/context.c ****         count += pThis->pSections[i].count;
 375              		.loc 1 64 23 is_stmt 0 view .LVU105
 376 0016 0468     		ldr	r4, [r0]
  64:mri/core/context.c ****         count += pThis->pSections[i].count;
 377              		.loc 1 64 34 view .LVU106
 378 0018 04EBCC03 		add	r3, r4, ip, lsl #3
  64:mri/core/context.c ****         count += pThis->pSections[i].count;
 379              		.loc 1 64 37 view .LVU107
 380 001c 5B68     		ldr	r3, [r3, #4]
  64:mri/core/context.c ****         count += pThis->pSections[i].count;
 381              		.loc 1 64 15 view .LVU108
 382 001e 7344     		add	r3, r3, lr
 383              	.LVL41:
  65:mri/core/context.c ****         if (index < count)
 384              		.loc 1 65 9 is_stmt 1 view .LVU109
  65:mri/core/context.c ****         if (index < count)
 385              		.loc 1 65 12 is_stmt 0 view .LVU110
 386 0020 8B42     		cmp	r3, r1
 387 0022 F2D9     		bls	.L24
  67:mri/core/context.c ****             pThis->pSections[i].pValues[index - base] = newValue;
 388              		.loc 1 67 13 is_stmt 1 view .LVU111
  67:mri/core/context.c ****             pThis->pSections[i].pValues[index - base] = newValue;
 389              		.loc 1 67 32 is_stmt 0 view .LVU112
 390 0024 54F83C30 		ldr	r3, [r4, ip, lsl #3]
 391              	.LVL42:
  67:mri/core/context.c ****             pThis->pSections[i].pValues[index - base] = newValue;
 392              		.loc 1 67 47 view .LVU113
 393 0028 A1EB0E01 		sub	r1, r1, lr
 394              	.LVL43:
  67:mri/core/context.c ****             pThis->pSections[i].pValues[index - base] = newValue;
 395              		.loc 1 67 55 view .LVU114
 396 002c 43F82120 		str	r2, [r3, r1, lsl #2]
 397              	.LVL44:
  68:mri/core/context.c ****             return;
 398              		.loc 1 68 13 is_stmt 1 view .LVU115
 399 0030 05E0     		b	.L22
 400              	.LVL45:
 401              	.L28:
  71:mri/core/context.c ****     __throw(bufferOverrunException);
 402              		.loc 1 71 5 view .LVU116
 403              	.LBB8:
 404              	.LBI8:
  71:mri/core/try_catch.h **** {
 405              		.loc 2 71 20 view .LVU117
 406              	.LBB9:
 407              		.loc 2 73 5 view .LVU118
 408              		.loc 2 73 73 is_stmt 0 view .LVU119
 409 0032 034A     		ldr	r2, .L29
 410              	.LVL46:
 411              		.loc 2 73 73 view .LVU120
 412 0034 1368     		ldr	r3, [r2]
 413 0036 012B     		cmp	r3, #1
 414 0038 B8BF     		it	lt
 415 003a 0123     		movlt	r3, #1
 416              		.loc 2 73 22 view .LVU121
ARM GAS  /tmp/ccj5sP08.s 			page 13


 417 003c 1360     		str	r3, [r2]
 418              	.LVL47:
 419              	.L22:
 420              		.loc 2 73 22 view .LVU122
 421              	.LBE9:
 422              	.LBE8:
  72:mri/core/context.c **** }
 423              		.loc 1 72 1 view .LVU123
 424 003e 10BD     		pop	{r4, pc}
 425              	.L30:
 426              		.align	2
 427              	.L29:
 428 0040 00000000 		.word	mriExceptionCode
 429              		.cfi_endproc
 430              	.LFE6:
 432              		.section	.text.mriContext_CopyToBuffer,"ax",%progbits
 433              		.align	1
 434              		.global	mriContext_CopyToBuffer
 435              		.syntax unified
 436              		.thumb
 437              		.thumb_func
 439              	mriContext_CopyToBuffer:
 440              	.LVL48:
 441              	.LFB7:
  77:mri/core/context.c **** {
 442              		.loc 1 77 1 is_stmt 1 view -0
 443              		.cfi_startproc
 444              		@ args = 0, pretend = 0, frame = 8
 445              		@ frame_needed = 0, uses_anonymous_args = 0
  77:mri/core/context.c **** {
 446              		.loc 1 77 1 is_stmt 0 view .LVU125
 447 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 448              	.LCFI5:
 449              		.cfi_def_cfa_offset 20
 450              		.cfi_offset 4, -20
 451              		.cfi_offset 5, -16
 452              		.cfi_offset 6, -12
 453              		.cfi_offset 7, -8
 454              		.cfi_offset 14, -4
 455 0002 83B0     		sub	sp, sp, #12
 456              	.LCFI6:
 457              		.cfi_def_cfa_offset 32
 458 0004 0746     		mov	r7, r0
 459 0006 0E46     		mov	r6, r1
  78:mri/core/context.c ****     uint32_t count = Context_Count(pThis);
 460              		.loc 1 78 5 is_stmt 1 view .LVU126
  78:mri/core/context.c ****     uint32_t count = Context_Count(pThis);
 461              		.loc 1 78 22 is_stmt 0 view .LVU127
 462 0008 FFF7FEFF 		bl	mriContext_Count
 463              	.LVL49:
  78:mri/core/context.c ****     uint32_t count = Context_Count(pThis);
 464              		.loc 1 78 22 view .LVU128
 465 000c 0546     		mov	r5, r0
 466              	.LVL50:
  79:mri/core/context.c ****     uint32_t i;
 467              		.loc 1 79 5 is_stmt 1 view .LVU129
  81:mri/core/context.c ****     for (i = 0 ; i < count ; i++)
ARM GAS  /tmp/ccj5sP08.s 			page 14


 468              		.loc 1 81 5 view .LVU130
  81:mri/core/context.c ****     for (i = 0 ; i < count ; i++)
 469              		.loc 1 81 12 is_stmt 0 view .LVU131
 470 000e 0024     		movs	r4, #0
  81:mri/core/context.c ****     for (i = 0 ; i < count ; i++)
 471              		.loc 1 81 5 view .LVU132
 472 0010 0BE0     		b	.L32
 473              	.LVL51:
 474              	.L33:
 475              	.LBB10:
  83:mri/core/context.c ****         uint32_t reg = Context_Get(pThis, i);
 476              		.loc 1 83 9 is_stmt 1 discriminator 3 view .LVU133
  83:mri/core/context.c ****         uint32_t reg = Context_Get(pThis, i);
 477              		.loc 1 83 24 is_stmt 0 discriminator 3 view .LVU134
 478 0012 2146     		mov	r1, r4
 479 0014 3846     		mov	r0, r7
 480 0016 FFF7FEFF 		bl	mriContext_Get
 481              	.LVL52:
  83:mri/core/context.c ****         uint32_t reg = Context_Get(pThis, i);
 482              		.loc 1 83 18 discriminator 3 view .LVU135
 483 001a 0190     		str	r0, [sp, #4]
  84:mri/core/context.c ****         writeBytesToBufferAsHex(pBuffer, &reg, sizeof(reg));
 484              		.loc 1 84 9 is_stmt 1 discriminator 3 view .LVU136
 485 001c 0422     		movs	r2, #4
 486 001e 0DEB0201 		add	r1, sp, r2
 487 0022 3046     		mov	r0, r6
 488 0024 FFF7FEFF 		bl	writeBytesToBufferAsHex
 489              	.LVL53:
 490              	.LBE10:
  81:mri/core/context.c ****     for (i = 0 ; i < count ; i++)
 491              		.loc 1 81 31 discriminator 3 view .LVU137
 492 0028 0134     		adds	r4, r4, #1
 493              	.LVL54:
 494              	.L32:
  81:mri/core/context.c ****     for (i = 0 ; i < count ; i++)
 495              		.loc 1 81 20 discriminator 1 view .LVU138
 496 002a AC42     		cmp	r4, r5
 497 002c F1D3     		bcc	.L33
  86:mri/core/context.c **** }
 498              		.loc 1 86 1 is_stmt 0 view .LVU139
 499 002e 03B0     		add	sp, sp, #12
 500              	.LCFI7:
 501              		.cfi_def_cfa_offset 20
 502              		@ sp needed
 503 0030 F0BD     		pop	{r4, r5, r6, r7, pc}
  86:mri/core/context.c **** }
 504              		.loc 1 86 1 view .LVU140
 505              		.cfi_endproc
 506              	.LFE7:
 508              		.section	.text.mriContext_CopyFromBuffer,"ax",%progbits
 509              		.align	1
 510              		.global	mriContext_CopyFromBuffer
 511              		.syntax unified
 512              		.thumb
 513              		.thumb_func
 515              	mriContext_CopyFromBuffer:
 516              	.LVL55:
ARM GAS  /tmp/ccj5sP08.s 			page 15


 517              	.LFB9:
  98:mri/core/context.c **** {
 518              		.loc 1 98 1 is_stmt 1 view -0
 519              		.cfi_startproc
 520              		@ args = 0, pretend = 0, frame = 8
 521              		@ frame_needed = 0, uses_anonymous_args = 0
  98:mri/core/context.c **** {
 522              		.loc 1 98 1 is_stmt 0 view .LVU142
 523 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 524              	.LCFI8:
 525              		.cfi_def_cfa_offset 20
 526              		.cfi_offset 4, -20
 527              		.cfi_offset 5, -16
 528              		.cfi_offset 6, -12
 529              		.cfi_offset 7, -8
 530              		.cfi_offset 14, -4
 531 0002 83B0     		sub	sp, sp, #12
 532              	.LCFI9:
 533              		.cfi_def_cfa_offset 32
 534 0004 0746     		mov	r7, r0
 535 0006 0E46     		mov	r6, r1
  99:mri/core/context.c ****     uint32_t count = Context_Count(pThis);
 536              		.loc 1 99 5 is_stmt 1 view .LVU143
  99:mri/core/context.c ****     uint32_t count = Context_Count(pThis);
 537              		.loc 1 99 22 is_stmt 0 view .LVU144
 538 0008 FFF7FEFF 		bl	mriContext_Count
 539              	.LVL56:
  99:mri/core/context.c ****     uint32_t count = Context_Count(pThis);
 540              		.loc 1 99 22 view .LVU145
 541 000c 0546     		mov	r5, r0
 542              	.LVL57:
 100:mri/core/context.c ****     uint32_t i;
 543              		.loc 1 100 5 is_stmt 1 view .LVU146
 102:mri/core/context.c ****     for (i = 0 ; i < count ; i++) {
 544              		.loc 1 102 5 view .LVU147
 102:mri/core/context.c ****     for (i = 0 ; i < count ; i++) {
 545              		.loc 1 102 12 is_stmt 0 view .LVU148
 546 000e 0024     		movs	r4, #0
 102:mri/core/context.c ****     for (i = 0 ; i < count ; i++) {
 547              		.loc 1 102 5 view .LVU149
 548 0010 0BE0     		b	.L36
 549              	.LVL58:
 550              	.L37:
 551              	.LBB11:
 103:mri/core/context.c ****         uint32_t reg;
 552              		.loc 1 103 9 is_stmt 1 discriminator 3 view .LVU150
 104:mri/core/context.c ****         readBytesFromBufferAsHex(pBuffer, &reg, sizeof(reg));
 553              		.loc 1 104 9 discriminator 3 view .LVU151
 554 0012 0422     		movs	r2, #4
 555 0014 0DEB0201 		add	r1, sp, r2
 556 0018 3046     		mov	r0, r6
 557 001a FFF7FEFF 		bl	readBytesFromBufferAsHex
 558              	.LVL59:
 105:mri/core/context.c ****         Context_Set(pThis, i, reg);
 559              		.loc 1 105 9 discriminator 3 view .LVU152
 560 001e 019A     		ldr	r2, [sp, #4]
 561 0020 2146     		mov	r1, r4
ARM GAS  /tmp/ccj5sP08.s 			page 16


 562 0022 3846     		mov	r0, r7
 563 0024 FFF7FEFF 		bl	mriContext_Set
 564              	.LVL60:
 565              	.LBE11:
 102:mri/core/context.c ****     for (i = 0 ; i < count ; i++) {
 566              		.loc 1 102 31 discriminator 3 view .LVU153
 567 0028 0134     		adds	r4, r4, #1
 568              	.LVL61:
 569              	.L36:
 102:mri/core/context.c ****     for (i = 0 ; i < count ; i++) {
 570              		.loc 1 102 20 discriminator 1 view .LVU154
 571 002a AC42     		cmp	r4, r5
 572 002c F1D3     		bcc	.L37
 107:mri/core/context.c **** }
 573              		.loc 1 107 1 is_stmt 0 view .LVU155
 574 002e 03B0     		add	sp, sp, #12
 575              	.LCFI10:
 576              		.cfi_def_cfa_offset 20
 577              		@ sp needed
 578 0030 F0BD     		pop	{r4, r5, r6, r7, pc}
 107:mri/core/context.c **** }
 579              		.loc 1 107 1 view .LVU156
 580              		.cfi_endproc
 581              	.LFE9:
 583              		.text
 584              	.Letext0:
 585              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 586              		.file 4 "/usr/arm-none-eabi/include/sys/_stdint.h"
 587              		.file 5 "/usr/lib/gcc/arm-none-eabi/12.2.0/include/stddef.h"
 588              		.file 6 "mri/core/buffer.h"
 589              		.file 7 "mri/core/context.h"
ARM GAS  /tmp/ccj5sP08.s 			page 17


DEFINED SYMBOLS
                            *ABS*:0000000000000000 context.c
     /tmp/ccj5sP08.s:21     .text.writeBytesToBufferAsHex:0000000000000000 $t
     /tmp/ccj5sP08.s:26     .text.writeBytesToBufferAsHex:0000000000000000 writeBytesToBufferAsHex
     /tmp/ccj5sP08.s:76     .text.readBytesFromBufferAsHex:0000000000000000 $t
     /tmp/ccj5sP08.s:81     .text.readBytesFromBufferAsHex:0000000000000000 readBytesFromBufferAsHex
     /tmp/ccj5sP08.s:131    .text.mriContext_Init:0000000000000000 $t
     /tmp/ccj5sP08.s:137    .text.mriContext_Init:0000000000000000 mriContext_Init
     /tmp/ccj5sP08.s:157    .text.mriContext_Count:0000000000000000 $t
     /tmp/ccj5sP08.s:163    .text.mriContext_Count:0000000000000000 mriContext_Count
     /tmp/ccj5sP08.s:213    .text.mriContext_Get:0000000000000000 $t
     /tmp/ccj5sP08.s:219    .text.mriContext_Get:0000000000000000 mriContext_Get
     /tmp/ccj5sP08.s:322    .text.mriContext_Get:0000000000000044 $d
     /tmp/ccj5sP08.s:327    .text.mriContext_Set:0000000000000000 $t
     /tmp/ccj5sP08.s:333    .text.mriContext_Set:0000000000000000 mriContext_Set
     /tmp/ccj5sP08.s:428    .text.mriContext_Set:0000000000000040 $d
     /tmp/ccj5sP08.s:433    .text.mriContext_CopyToBuffer:0000000000000000 $t
     /tmp/ccj5sP08.s:439    .text.mriContext_CopyToBuffer:0000000000000000 mriContext_CopyToBuffer
     /tmp/ccj5sP08.s:509    .text.mriContext_CopyFromBuffer:0000000000000000 $t
     /tmp/ccj5sP08.s:515    .text.mriContext_CopyFromBuffer:0000000000000000 mriContext_CopyFromBuffer

UNDEFINED SYMBOLS
mriBuffer_WriteByteAsHex
mriBuffer_ReadByteAsHex
mriExceptionCode
