ARM GAS  /tmp/ccX6djba.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"cmd_vcont.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "mri/core/cmd_vcont.c"
  20              		.section	.text.justAdvancedPastBreakpoint,"ax",%progbits
  21              		.align	1
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	justAdvancedPastBreakpoint:
  27              	.LVL0:
  28              	.LFB22:
   1:mri/core/cmd_vcont.c **** /* Copyright 2022 Adam Green (https://github.com/adamgreen/)
   2:mri/core/cmd_vcont.c **** 
   3:mri/core/cmd_vcont.c ****    Licensed under the Apache License, Version 2.0 (the "License");
   4:mri/core/cmd_vcont.c ****    you may not use this file except in compliance with the License.
   5:mri/core/cmd_vcont.c ****    You may obtain a copy of the License at
   6:mri/core/cmd_vcont.c **** 
   7:mri/core/cmd_vcont.c ****        http://www.apache.org/licenses/LICENSE-2.0
   8:mri/core/cmd_vcont.c **** 
   9:mri/core/cmd_vcont.c ****    Unless required by applicable law or agreed to in writing, software
  10:mri/core/cmd_vcont.c ****    distributed under the License is distributed on an "AS IS" BASIS,
  11:mri/core/cmd_vcont.c ****    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  12:mri/core/cmd_vcont.c ****    See the License for the specific language governing permissions and
  13:mri/core/cmd_vcont.c ****    limitations under the License.
  14:mri/core/cmd_vcont.c **** */
  15:mri/core/cmd_vcont.c **** /* Handler for gdb's vCont and vCont? commands which support multithreaded single stepping/continui
  16:mri/core/cmd_vcont.c **** #include <core/libc.h>
  17:mri/core/cmd_vcont.c **** #include <core/cmd_vcont.h>
  18:mri/core/cmd_vcont.c **** #include <core/buffer.h>
  19:mri/core/cmd_vcont.c **** #include <core/cmd_common.h>
  20:mri/core/cmd_vcont.c **** #include <core/cmd_continue.h>
  21:mri/core/cmd_vcont.c **** #include <core/cmd_registers.h>
  22:mri/core/cmd_vcont.c **** #include <core/cmd_step.h>
  23:mri/core/cmd_vcont.c **** #include <core/core.h>
  24:mri/core/cmd_vcont.c **** #include <core/mri.h>
  25:mri/core/cmd_vcont.c **** #include <core/platforms.h>
  26:mri/core/cmd_vcont.c **** #include <core/try_catch.h>
  27:mri/core/cmd_vcont.c **** 
  28:mri/core/cmd_vcont.c **** 
  29:mri/core/cmd_vcont.c **** typedef enum
  30:mri/core/cmd_vcont.c **** {
ARM GAS  /tmp/ccX6djba.s 			page 2


  31:mri/core/cmd_vcont.c ****     THREAD_ID_ALL = -1,
  32:mri/core/cmd_vcont.c ****     THREAD_ID_NONE,
  33:mri/core/cmd_vcont.c ****     THREAD_ID_SPECIFIC
  34:mri/core/cmd_vcont.c **** } ThreadIdType;
  35:mri/core/cmd_vcont.c **** 
  36:mri/core/cmd_vcont.c **** typedef struct
  37:mri/core/cmd_vcont.c **** {
  38:mri/core/cmd_vcont.c ****     uint32_t     id;
  39:mri/core/cmd_vcont.c ****     ThreadIdType type;
  40:mri/core/cmd_vcont.c **** } ThreadId;
  41:mri/core/cmd_vcont.c **** 
  42:mri/core/cmd_vcont.c **** typedef enum
  43:mri/core/cmd_vcont.c **** {
  44:mri/core/cmd_vcont.c ****     ACTION_NONE,
  45:mri/core/cmd_vcont.c ****     ACTION_CONTINUE,
  46:mri/core/cmd_vcont.c ****     ACTION_SINGLE_STEP,
  47:mri/core/cmd_vcont.c ****     ACTION_RANGED_SINGLE_STEP
  48:mri/core/cmd_vcont.c **** } ActionType;
  49:mri/core/cmd_vcont.c **** 
  50:mri/core/cmd_vcont.c **** typedef struct
  51:mri/core/cmd_vcont.c **** {
  52:mri/core/cmd_vcont.c ****     ThreadId        threadId;
  53:mri/core/cmd_vcont.c ****     AddressRange    range;
  54:mri/core/cmd_vcont.c ****     ActionType      type;
  55:mri/core/cmd_vcont.c **** } Action;
  56:mri/core/cmd_vcont.c **** 
  57:mri/core/cmd_vcont.c **** 
  58:mri/core/cmd_vcont.c **** static uint32_t handleVContQueryCommand(void);
  59:mri/core/cmd_vcont.c **** static uint32_t handleVContCommand(void);
  60:mri/core/cmd_vcont.c **** static void     firstParsePass(Buffer* pBuffer, Action* pContinueAction, Action* pStepAction);
  61:mri/core/cmd_vcont.c **** static int      isActionMoreSpecificThanCurrent(Action* pCurr, Action* pNew);
  62:mri/core/cmd_vcont.c **** static uint32_t getActionPriority(Action* pAction);
  63:mri/core/cmd_vcont.c **** static int      isActionSpecificToNonHaltedThreadId(const Action* pAction);
  64:mri/core/cmd_vcont.c **** static int      isActionSpecificToHaltedThreadId(const Action* pAction);
  65:mri/core/cmd_vcont.c **** static Action   parseAction(Buffer* pBuffer);
  66:mri/core/cmd_vcont.c **** static Action   parseContinueAction(Buffer* pBuffer);
  67:mri/core/cmd_vcont.c **** static Action   parseContinueWithSignalAction(Buffer* pBuffer);
  68:mri/core/cmd_vcont.c **** static Action   parseSingleStepAction(Buffer* pBuffer);
  69:mri/core/cmd_vcont.c **** static Action   parseSingleStepWithSignalAction(Buffer* pBuffer);
  70:mri/core/cmd_vcont.c **** static Action   parseRangedSingleStepAction(Buffer* pBuffer);
  71:mri/core/cmd_vcont.c **** static AddressRange parseAddressRange(Buffer* pBuffer);
  72:mri/core/cmd_vcont.c **** static ThreadId parseOptionalThreadId(Buffer* pBuffer);
  73:mri/core/cmd_vcont.c **** static uint32_t handleSingleStepAndContinueCommands(const Action* pContinueAction, const Action* pS
  74:mri/core/cmd_vcont.c **** static uint32_t handleAction(const Action* pAction);
  75:mri/core/cmd_vcont.c **** static uint32_t handleSingleStepAndContinueCommandsWithSetThreadState(Buffer* pBuffer,
  76:mri/core/cmd_vcont.c ****                                                                       const Action* pContinueAction
  77:mri/core/cmd_vcont.c ****                                                                       const Action* pStepAction);
  78:mri/core/cmd_vcont.c **** static uint32_t justAdvancedPastBreakpoint(uint32_t continueReturn);
  79:mri/core/cmd_vcont.c **** static uint32_t secondParsePass(Buffer* pBuffer);
  80:mri/core/cmd_vcont.c **** static uint32_t handleActionWithSetThreadState(const Action* pAction);
  81:mri/core/cmd_vcont.c **** static uint32_t getThreadIdFromAction(const Action* pAction);
  82:mri/core/cmd_vcont.c **** /* Handle the extended 'v' commands used by gdb.
  83:mri/core/cmd_vcont.c **** 
  84:mri/core/cmd_vcont.c ****     Command Format: vSSS
  85:mri/core/cmd_vcont.c ****     Where SSS is a variable length string indicating which extended command is being sent to the st
  86:mri/core/cmd_vcont.c **** */
  87:mri/core/cmd_vcont.c **** uint32_t HandleVContCommands(void)
ARM GAS  /tmp/ccX6djba.s 			page 3


  88:mri/core/cmd_vcont.c **** {
  89:mri/core/cmd_vcont.c ****     Buffer*             pBuffer = GetBuffer();
  90:mri/core/cmd_vcont.c ****     static const char   vContQueryCommand[] = "Cont?";
  91:mri/core/cmd_vcont.c ****     static const char   vContCommand[] = "Cont";
  92:mri/core/cmd_vcont.c **** 
  93:mri/core/cmd_vcont.c ****     if (Buffer_MatchesString(pBuffer, vContQueryCommand, sizeof(vContQueryCommand)-1))
  94:mri/core/cmd_vcont.c ****     {
  95:mri/core/cmd_vcont.c ****         return handleVContQueryCommand();
  96:mri/core/cmd_vcont.c ****     }
  97:mri/core/cmd_vcont.c ****     else if (Buffer_MatchesString(pBuffer, vContCommand, sizeof(vContCommand)-1))
  98:mri/core/cmd_vcont.c ****     {
  99:mri/core/cmd_vcont.c ****         return handleVContCommand();
 100:mri/core/cmd_vcont.c ****     }
 101:mri/core/cmd_vcont.c ****     else
 102:mri/core/cmd_vcont.c ****     {
 103:mri/core/cmd_vcont.c ****         PrepareEmptyResponseForUnknownCommand();
 104:mri/core/cmd_vcont.c ****         return 0;
 105:mri/core/cmd_vcont.c ****     }
 106:mri/core/cmd_vcont.c **** }
 107:mri/core/cmd_vcont.c **** 
 108:mri/core/cmd_vcont.c **** static uint32_t handleVContQueryCommand(void)
 109:mri/core/cmd_vcont.c **** {
 110:mri/core/cmd_vcont.c ****     Buffer* pBuffer = GetInitializedBuffer();
 111:mri/core/cmd_vcont.c ****     Buffer_WriteString(pBuffer, "vCont;c;C;s;S;r");
 112:mri/core/cmd_vcont.c ****     return 0;
 113:mri/core/cmd_vcont.c **** }
 114:mri/core/cmd_vcont.c **** 
 115:mri/core/cmd_vcont.c **** /* Handle the "vCont" command used by gdb for extended single stepping/continuing of execution.
 116:mri/core/cmd_vcont.c **** 
 117:mri/core/cmd_vcont.c ****     Command Format: vCont[;action[:thread-id]]
 118:mri/core/cmd_vcont.c ****     Where supported actions are currently:
 119:mri/core/cmd_vcont.c ****         c - Continue execution.
 120:mri/core/cmd_vcont.c ****         CAA - Continue execution where AA is the signal to be set. Signals ignored by MRI.
 121:mri/core/cmd_vcont.c ****         s - Single step one instruction.
 122:mri/core/cmd_vcont.c ****         SAA - Single step one instruction where AA is the signal to be set. Signals ignored by MRI.
 123:mri/core/cmd_vcont.c ****         rAAAAAAAA,BBBBBBBB - Single step through instructions while in address range between AAAAAA
 124:mri/core/cmd_vcont.c ****                              BBBBBBBB (exclusive).
 125:mri/core/cmd_vcont.c ****     Where thread-id indicates threads to which this action should be applied. -1 means all threads.
 126:mri/core/cmd_vcont.c ****     is specified then this is the default action to be applied to threads which aren't otherwise sp
 127:mri/core/cmd_vcont.c ****     action.
 128:mri/core/cmd_vcont.c **** */
 129:mri/core/cmd_vcont.c **** static uint32_t handleVContCommand(void)
 130:mri/core/cmd_vcont.c **** {
 131:mri/core/cmd_vcont.c ****     Buffer*           pBuffer = GetBuffer();
 132:mri/core/cmd_vcont.c ****     Buffer            replayBuffer = *pBuffer;
 133:mri/core/cmd_vcont.c ****     Action            continueAction;
 134:mri/core/cmd_vcont.c ****     Action            stepAction;
 135:mri/core/cmd_vcont.c **** 
 136:mri/core/cmd_vcont.c ****     mri_memset(&continueAction, 0, sizeof(continueAction));
 137:mri/core/cmd_vcont.c ****     mri_memset(&stepAction, 0, sizeof(stepAction));
 138:mri/core/cmd_vcont.c **** 
 139:mri/core/cmd_vcont.c ****     __try
 140:mri/core/cmd_vcont.c ****         firstParsePass(pBuffer, &continueAction, &stepAction);
 141:mri/core/cmd_vcont.c ****     __catch
 142:mri/core/cmd_vcont.c ****         return 0;
 143:mri/core/cmd_vcont.c **** 
 144:mri/core/cmd_vcont.c ****     if (Platform_RtosIsSetThreadStateSupported())
ARM GAS  /tmp/ccX6djba.s 			page 4


 145:mri/core/cmd_vcont.c ****         return handleSingleStepAndContinueCommandsWithSetThreadState(&replayBuffer, &continueAction
 146:mri/core/cmd_vcont.c ****     else
 147:mri/core/cmd_vcont.c ****         return handleSingleStepAndContinueCommands(&continueAction, &stepAction);
 148:mri/core/cmd_vcont.c **** }
 149:mri/core/cmd_vcont.c **** 
 150:mri/core/cmd_vcont.c **** static void firstParsePass(Buffer* pBuffer, Action* pContinueAction, Action* pStepAction)
 151:mri/core/cmd_vcont.c **** {
 152:mri/core/cmd_vcont.c ****     uint32_t actionCount = 0;
 153:mri/core/cmd_vcont.c ****     Action   action;
 154:mri/core/cmd_vcont.c **** 
 155:mri/core/cmd_vcont.c ****     while (Buffer_BytesLeft(pBuffer) > 0 && Buffer_IsNextCharEqualTo(pBuffer, ';'))
 156:mri/core/cmd_vcont.c ****     {
 157:mri/core/cmd_vcont.c ****         __try
 158:mri/core/cmd_vcont.c ****         {
 159:mri/core/cmd_vcont.c ****             action = parseAction(pBuffer);
 160:mri/core/cmd_vcont.c ****         }
 161:mri/core/cmd_vcont.c ****         __catch
 162:mri/core/cmd_vcont.c ****         {
 163:mri/core/cmd_vcont.c ****             PrepareStringResponse(MRI_ERROR_INVALID_ARGUMENT);
 164:mri/core/cmd_vcont.c ****             __rethrow;
 165:mri/core/cmd_vcont.c ****         }
 166:mri/core/cmd_vcont.c **** 
 167:mri/core/cmd_vcont.c ****         actionCount++;
 168:mri/core/cmd_vcont.c ****         switch (action.type)
 169:mri/core/cmd_vcont.c ****         {
 170:mri/core/cmd_vcont.c ****             case ACTION_RANGED_SINGLE_STEP:
 171:mri/core/cmd_vcont.c ****             case ACTION_SINGLE_STEP:
 172:mri/core/cmd_vcont.c ****                 if (isActionMoreSpecificThanCurrent(pStepAction, &action))
 173:mri/core/cmd_vcont.c ****                     *pStepAction = action;
 174:mri/core/cmd_vcont.c ****                 break;
 175:mri/core/cmd_vcont.c ****             case ACTION_CONTINUE:
 176:mri/core/cmd_vcont.c ****                 if (isActionMoreSpecificThanCurrent(pContinueAction, &action))
 177:mri/core/cmd_vcont.c ****                     *pContinueAction = action;
 178:mri/core/cmd_vcont.c ****                 break;
 179:mri/core/cmd_vcont.c ****             default:
 180:mri/core/cmd_vcont.c ****                 break;
 181:mri/core/cmd_vcont.c ****         }
 182:mri/core/cmd_vcont.c ****     }
 183:mri/core/cmd_vcont.c ****     if (Buffer_BytesLeft(pBuffer) > 0)
 184:mri/core/cmd_vcont.c ****     {
 185:mri/core/cmd_vcont.c ****         /* After processing all arguments, there should be no bytes left in packet. */
 186:mri/core/cmd_vcont.c ****         PrepareStringResponse(MRI_ERROR_INVALID_ARGUMENT);
 187:mri/core/cmd_vcont.c ****         __throw(invalidArgumentException);
 188:mri/core/cmd_vcont.c ****     }
 189:mri/core/cmd_vcont.c ****     if (!Platform_RtosIsSetThreadStateSupported() && pContinueAction->type == ACTION_NONE && pStepA
 190:mri/core/cmd_vcont.c ****     {
 191:mri/core/cmd_vcont.c ****         PrepareStringResponse(MRI_ERROR_INVALID_ARGUMENT);
 192:mri/core/cmd_vcont.c ****         __throw(invalidArgumentException);
 193:mri/core/cmd_vcont.c ****     }
 194:mri/core/cmd_vcont.c ****     if (Platform_RtosIsSetThreadStateSupported() && actionCount == 0)
 195:mri/core/cmd_vcont.c ****     {
 196:mri/core/cmd_vcont.c ****         PrepareStringResponse(MRI_ERROR_INVALID_ARGUMENT);
 197:mri/core/cmd_vcont.c ****         __throw(invalidArgumentException);
 198:mri/core/cmd_vcont.c ****     }
 199:mri/core/cmd_vcont.c **** }
 200:mri/core/cmd_vcont.c **** 
 201:mri/core/cmd_vcont.c **** static int isActionMoreSpecificThanCurrent(Action* pCurr, Action* pNew)
ARM GAS  /tmp/ccX6djba.s 			page 5


 202:mri/core/cmd_vcont.c **** {
 203:mri/core/cmd_vcont.c ****     uint32_t currPriority = getActionPriority(pCurr);
 204:mri/core/cmd_vcont.c ****     uint32_t newPriority = getActionPriority(pNew);
 205:mri/core/cmd_vcont.c ****     return newPriority > currPriority;
 206:mri/core/cmd_vcont.c **** }
 207:mri/core/cmd_vcont.c **** 
 208:mri/core/cmd_vcont.c **** static uint32_t getActionPriority(Action* pAction)
 209:mri/core/cmd_vcont.c **** {
 210:mri/core/cmd_vcont.c ****     /* When Platform_RtosSetThreadState() isn't supported, we will treat actions (ie. single steppi
 211:mri/core/cmd_vcont.c ****        specific to a thread other than the halted thread as though it was specific to the halted th
 212:mri/core/cmd_vcont.c ****        single stepping an arbitrary thread in GDB will result in single stepping the current thread
 213:mri/core/cmd_vcont.c ****        returning a cryptic E01 parsing error to the user.
 214:mri/core/cmd_vcont.c ****        When Platform_RtosSetThreadState() is supported, those same actions specific to a thread oth
 215:mri/core/cmd_vcont.c ****        currently halted have no impact what so ever on the currently halted thread.
 216:mri/core/cmd_vcont.c ****     */
 217:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 218:mri/core/cmd_vcont.c ****     if (pAction->type == ACTION_NONE)
 219:mri/core/cmd_vcont.c ****         returnValue = 0;
 220:mri/core/cmd_vcont.c ****     else if (Platform_RtosIsSetThreadStateSupported() && isActionSpecificToNonHaltedThreadId(pActio
 221:mri/core/cmd_vcont.c ****         returnValue = 0;
 222:mri/core/cmd_vcont.c ****     else if (pAction->threadId.type == THREAD_ID_NONE)
 223:mri/core/cmd_vcont.c ****         returnValue = 1;
 224:mri/core/cmd_vcont.c ****     else if (!Platform_RtosIsSetThreadStateSupported() && isActionSpecificToNonHaltedThreadId(pActi
 225:mri/core/cmd_vcont.c ****         returnValue = 2;
 226:mri/core/cmd_vcont.c ****     else if (pAction->threadId.type == THREAD_ID_ALL)
 227:mri/core/cmd_vcont.c ****         returnValue = 3;
 228:mri/core/cmd_vcont.c ****     else if (isActionSpecificToHaltedThreadId(pAction))
 229:mri/core/cmd_vcont.c ****         returnValue = 4;
 230:mri/core/cmd_vcont.c ****     return returnValue;
 231:mri/core/cmd_vcont.c **** }
 232:mri/core/cmd_vcont.c **** 
 233:mri/core/cmd_vcont.c **** static int isActionSpecificToNonHaltedThreadId(const Action* pAction)
 234:mri/core/cmd_vcont.c **** {
 235:mri/core/cmd_vcont.c ****     return pAction->threadId.type == THREAD_ID_SPECIFIC && pAction->threadId.id != Platform_RtosGet
 236:mri/core/cmd_vcont.c **** }
 237:mri/core/cmd_vcont.c **** 
 238:mri/core/cmd_vcont.c **** static int isActionSpecificToHaltedThreadId(const Action* pAction)
 239:mri/core/cmd_vcont.c **** {
 240:mri/core/cmd_vcont.c ****     return pAction->threadId.type == THREAD_ID_SPECIFIC && pAction->threadId.id == Platform_RtosGet
 241:mri/core/cmd_vcont.c **** }
 242:mri/core/cmd_vcont.c **** 
 243:mri/core/cmd_vcont.c **** static Action parseAction(Buffer* pBuffer)
 244:mri/core/cmd_vcont.c **** {
 245:mri/core/cmd_vcont.c ****     char   ch = Buffer_ReadChar(pBuffer);
 246:mri/core/cmd_vcont.c ****     Action action;
 247:mri/core/cmd_vcont.c ****     mri_memset(&action, 0, sizeof(action));
 248:mri/core/cmd_vcont.c ****     switch (ch)
 249:mri/core/cmd_vcont.c ****     {
 250:mri/core/cmd_vcont.c ****         case 'c':
 251:mri/core/cmd_vcont.c ****             return parseContinueAction(pBuffer);
 252:mri/core/cmd_vcont.c ****         case 'C':
 253:mri/core/cmd_vcont.c ****             return parseContinueWithSignalAction(pBuffer);
 254:mri/core/cmd_vcont.c ****         case 'r':
 255:mri/core/cmd_vcont.c ****             return parseRangedSingleStepAction(pBuffer);
 256:mri/core/cmd_vcont.c ****         case 's':
 257:mri/core/cmd_vcont.c ****             return parseSingleStepAction(pBuffer);
 258:mri/core/cmd_vcont.c ****         case 'S':
ARM GAS  /tmp/ccX6djba.s 			page 6


 259:mri/core/cmd_vcont.c ****             return parseSingleStepWithSignalAction(pBuffer);
 260:mri/core/cmd_vcont.c ****         default:
 261:mri/core/cmd_vcont.c ****             setExceptionCode(invalidArgumentException);
 262:mri/core/cmd_vcont.c ****             return action;
 263:mri/core/cmd_vcont.c ****     }
 264:mri/core/cmd_vcont.c **** }
 265:mri/core/cmd_vcont.c **** 
 266:mri/core/cmd_vcont.c **** static Action parseContinueAction(Buffer* pBuffer)
 267:mri/core/cmd_vcont.c **** {
 268:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_CONTINUE };
 269:mri/core/cmd_vcont.c ****     action.threadId  = parseOptionalThreadId(pBuffer);
 270:mri/core/cmd_vcont.c ****     return action;
 271:mri/core/cmd_vcont.c **** }
 272:mri/core/cmd_vcont.c **** 
 273:mri/core/cmd_vcont.c **** static Action parseContinueWithSignalAction(Buffer* pBuffer)
 274:mri/core/cmd_vcont.c **** {
 275:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_CONTINUE };
 276:mri/core/cmd_vcont.c **** 
 277:mri/core/cmd_vcont.c ****     __try
 278:mri/core/cmd_vcont.c ****     {
 279:mri/core/cmd_vcont.c ****         /* Fetch signal value but ignore it. */
 280:mri/core/cmd_vcont.c ****         __throwing_func( Buffer_ReadByteAsHex(pBuffer) );
 281:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 282:mri/core/cmd_vcont.c ****     }
 283:mri/core/cmd_vcont.c ****     __catch
 284:mri/core/cmd_vcont.c ****     {
 285:mri/core/cmd_vcont.c ****         __rethrow_and_return(action);
 286:mri/core/cmd_vcont.c ****     }
 287:mri/core/cmd_vcont.c ****     return action;
 288:mri/core/cmd_vcont.c **** }
 289:mri/core/cmd_vcont.c **** 
 290:mri/core/cmd_vcont.c **** static Action parseSingleStepAction(Buffer* pBuffer)
 291:mri/core/cmd_vcont.c **** {
 292:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_SINGLE_STEP };
 293:mri/core/cmd_vcont.c ****     action.threadId  = parseOptionalThreadId(pBuffer);
 294:mri/core/cmd_vcont.c ****     return action;
 295:mri/core/cmd_vcont.c **** }
 296:mri/core/cmd_vcont.c **** 
 297:mri/core/cmd_vcont.c **** static Action parseSingleStepWithSignalAction(Buffer* pBuffer)
 298:mri/core/cmd_vcont.c **** {
 299:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_SINGLE_STEP };
 300:mri/core/cmd_vcont.c ****     __try
 301:mri/core/cmd_vcont.c ****     {
 302:mri/core/cmd_vcont.c ****         /* Fetch signal value but ignore it. */
 303:mri/core/cmd_vcont.c ****         __throwing_func( Buffer_ReadByteAsHex(pBuffer) );
 304:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 305:mri/core/cmd_vcont.c ****     }
 306:mri/core/cmd_vcont.c ****     __catch
 307:mri/core/cmd_vcont.c ****     {
 308:mri/core/cmd_vcont.c ****         __rethrow_and_return(action);
 309:mri/core/cmd_vcont.c ****     }
 310:mri/core/cmd_vcont.c ****     return action;
 311:mri/core/cmd_vcont.c **** }
 312:mri/core/cmd_vcont.c **** 
 313:mri/core/cmd_vcont.c **** static Action parseRangedSingleStepAction(Buffer* pBuffer)
 314:mri/core/cmd_vcont.c **** {
 315:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_RANGED_SINGLE_STEP };
ARM GAS  /tmp/ccX6djba.s 			page 7


 316:mri/core/cmd_vcont.c ****     AddressRange range = { 0, 0 };
 317:mri/core/cmd_vcont.c ****     __try
 318:mri/core/cmd_vcont.c ****     {
 319:mri/core/cmd_vcont.c ****         __throwing_func( action.range = parseAddressRange(pBuffer) );
 320:mri/core/cmd_vcont.c ****         __throwing_func( action.threadId  = parseOptionalThreadId(pBuffer) );
 321:mri/core/cmd_vcont.c ****         (void)range;
 322:mri/core/cmd_vcont.c ****     }
 323:mri/core/cmd_vcont.c ****     __catch
 324:mri/core/cmd_vcont.c ****     {
 325:mri/core/cmd_vcont.c ****         __rethrow_and_return(action);
 326:mri/core/cmd_vcont.c ****     }
 327:mri/core/cmd_vcont.c ****     return action;
 328:mri/core/cmd_vcont.c **** }
 329:mri/core/cmd_vcont.c **** 
 330:mri/core/cmd_vcont.c **** static AddressRange parseAddressRange(Buffer* pBuffer)
 331:mri/core/cmd_vcont.c **** {
 332:mri/core/cmd_vcont.c ****     AddressRange range = {0, 0};
 333:mri/core/cmd_vcont.c ****     __try
 334:mri/core/cmd_vcont.c ****     {
 335:mri/core/cmd_vcont.c ****         __throwing_func( range.start = Buffer_ReadUIntegerAsHex(pBuffer) );
 336:mri/core/cmd_vcont.c ****         __throwing_func( ThrowIfNextCharIsNotEqualTo(pBuffer, ',') );
 337:mri/core/cmd_vcont.c ****         __throwing_func( range.end = Buffer_ReadUIntegerAsHex(pBuffer) );
 338:mri/core/cmd_vcont.c ****     }
 339:mri/core/cmd_vcont.c ****     __catch
 340:mri/core/cmd_vcont.c ****     {
 341:mri/core/cmd_vcont.c ****         __rethrow_and_return(range);
 342:mri/core/cmd_vcont.c ****     }
 343:mri/core/cmd_vcont.c ****     return range;
 344:mri/core/cmd_vcont.c **** }
 345:mri/core/cmd_vcont.c **** 
 346:mri/core/cmd_vcont.c **** static ThreadId parseOptionalThreadId(Buffer* pBuffer)
 347:mri/core/cmd_vcont.c **** {
 348:mri/core/cmd_vcont.c ****     static const char negativeOne[] = "-1";
 349:mri/core/cmd_vcont.c ****     ThreadId          threadId = { 0, THREAD_ID_NONE };
 350:mri/core/cmd_vcont.c **** 
 351:mri/core/cmd_vcont.c ****     if (Buffer_BytesLeft(pBuffer) == 0 || !Buffer_IsNextCharEqualTo(pBuffer, ':'))
 352:mri/core/cmd_vcont.c ****         return threadId;
 353:mri/core/cmd_vcont.c **** 
 354:mri/core/cmd_vcont.c ****     if (Buffer_MatchesString(pBuffer, negativeOne, sizeof(negativeOne)-1))
 355:mri/core/cmd_vcont.c ****     {
 356:mri/core/cmd_vcont.c ****         threadId.type = THREAD_ID_ALL;
 357:mri/core/cmd_vcont.c ****         return threadId;
 358:mri/core/cmd_vcont.c ****     }
 359:mri/core/cmd_vcont.c **** 
 360:mri/core/cmd_vcont.c ****     __try
 361:mri/core/cmd_vcont.c ****     {
 362:mri/core/cmd_vcont.c ****         __throwing_func( threadId.id = Buffer_ReadUIntegerAsHex(pBuffer) );
 363:mri/core/cmd_vcont.c ****         threadId.type = THREAD_ID_SPECIFIC;
 364:mri/core/cmd_vcont.c ****     }
 365:mri/core/cmd_vcont.c ****     __catch
 366:mri/core/cmd_vcont.c ****     {
 367:mri/core/cmd_vcont.c ****         __rethrow_and_return(threadId);
 368:mri/core/cmd_vcont.c ****     }
 369:mri/core/cmd_vcont.c **** 
 370:mri/core/cmd_vcont.c ****     return threadId;
 371:mri/core/cmd_vcont.c **** }
 372:mri/core/cmd_vcont.c **** 
ARM GAS  /tmp/ccX6djba.s 			page 8


 373:mri/core/cmd_vcont.c **** static uint32_t handleSingleStepAndContinueCommands(const Action* pContinueAction, const Action* pS
 374:mri/core/cmd_vcont.c **** {
 375:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 376:mri/core/cmd_vcont.c **** 
 377:mri/core/cmd_vcont.c ****     if (pStepAction->type != ACTION_NONE)
 378:mri/core/cmd_vcont.c ****         returnValue |= handleAction(pStepAction);
 379:mri/core/cmd_vcont.c ****     else
 380:mri/core/cmd_vcont.c ****         returnValue |= handleAction(pContinueAction);
 381:mri/core/cmd_vcont.c **** 
 382:mri/core/cmd_vcont.c ****     return returnValue;
 383:mri/core/cmd_vcont.c **** }
 384:mri/core/cmd_vcont.c **** 
 385:mri/core/cmd_vcont.c **** static uint32_t handleAction(const Action* pAction)
 386:mri/core/cmd_vcont.c **** {
 387:mri/core/cmd_vcont.c ****     const   int       noSetPC = 0;
 388:mri/core/cmd_vcont.c ****     const   uint32_t  newPC = 0;
 389:mri/core/cmd_vcont.c ****     uint32_t          returnValue = 0;
 390:mri/core/cmd_vcont.c **** 
 391:mri/core/cmd_vcont.c ****     /* No matter what thread ID is specified, it will be treated as though it was the halting threa
 392:mri/core/cmd_vcont.c ****        all a stub running without Platform_RtosSetThreadState() can handle anyway. */
 393:mri/core/cmd_vcont.c ****     switch (pAction->type)
 394:mri/core/cmd_vcont.c ****     {
 395:mri/core/cmd_vcont.c ****         case ACTION_CONTINUE:
 396:mri/core/cmd_vcont.c ****             return ContinueExecution(noSetPC, newPC);
 397:mri/core/cmd_vcont.c ****         case ACTION_SINGLE_STEP:
 398:mri/core/cmd_vcont.c ****             return HandleSingleStepCommand();
 399:mri/core/cmd_vcont.c ****         case ACTION_RANGED_SINGLE_STEP:
 400:mri/core/cmd_vcont.c ****             returnValue = HandleSingleStepCommand();
 401:mri/core/cmd_vcont.c ****             if (returnValue)
 402:mri/core/cmd_vcont.c ****                 SetSingleSteppingRange(&pAction->range);
 403:mri/core/cmd_vcont.c ****             return returnValue;
 404:mri/core/cmd_vcont.c ****         default:
 405:mri/core/cmd_vcont.c ****             PrepareStringResponse(MRI_ERROR_INVALID_ARGUMENT);
 406:mri/core/cmd_vcont.c ****             return 0;
 407:mri/core/cmd_vcont.c ****    }
 408:mri/core/cmd_vcont.c **** }
 409:mri/core/cmd_vcont.c **** 
 410:mri/core/cmd_vcont.c **** static uint32_t handleSingleStepAndContinueCommandsWithSetThreadState(Buffer* pBuffer,
 411:mri/core/cmd_vcont.c ****                                                                       const Action* pContinueAction
 412:mri/core/cmd_vcont.c ****                                                                       const Action* pStepAction)
 413:mri/core/cmd_vcont.c **** {
 414:mri/core/cmd_vcont.c ****     if (pContinueAction->type != ACTION_NONE || pStepAction->type != ACTION_NONE) {
 415:mri/core/cmd_vcont.c ****         uint32_t skippedHardcodedBreakpoint = SkipHardcodedBreakpoint();
 416:mri/core/cmd_vcont.c ****         if (pStepAction->type != ACTION_NONE && justAdvancedPastBreakpoint(skippedHardcodedBreakpoi
 417:mri/core/cmd_vcont.c ****         {
 418:mri/core/cmd_vcont.c ****             /* Treat the advance over hardcoded breakpoints as the single step and don't resume exe
 419:mri/core/cmd_vcont.c ****                 stop response instead. */
 420:mri/core/cmd_vcont.c ****             return Send_T_StopResponse();
 421:mri/core/cmd_vcont.c ****         }
 422:mri/core/cmd_vcont.c ****     }
 423:mri/core/cmd_vcont.c **** 
 424:mri/core/cmd_vcont.c ****     return secondParsePass(pBuffer);
 425:mri/core/cmd_vcont.c **** }
 426:mri/core/cmd_vcont.c **** 
 427:mri/core/cmd_vcont.c **** static uint32_t justAdvancedPastBreakpoint(uint32_t continueReturn)
 428:mri/core/cmd_vcont.c **** {
  29              		.loc 1 428 1 view -0
ARM GAS  /tmp/ccX6djba.s 			page 9


  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
 429:mri/core/cmd_vcont.c ****     return continueReturn & HANDLER_RETURN_SKIPPED_OVER_BREAK;
  34              		.loc 1 429 5 view .LVU1
 430:mri/core/cmd_vcont.c **** }
  35              		.loc 1 430 1 is_stmt 0 view .LVU2
  36 0000 00F00400 		and	r0, r0, #4
  37              	.LVL1:
  38              		.loc 1 430 1 view .LVU3
  39 0004 7047     		bx	lr
  40              		.cfi_endproc
  41              	.LFE22:
  43              		.section	.text.getThreadIdFromAction,"ax",%progbits
  44              		.align	1
  45              		.syntax unified
  46              		.thumb
  47              		.thumb_func
  49              	getThreadIdFromAction:
  50              	.LVL2:
  51              	.LFB25:
 431:mri/core/cmd_vcont.c **** 
 432:mri/core/cmd_vcont.c **** static uint32_t secondParsePass(Buffer* pBuffer)
 433:mri/core/cmd_vcont.c **** {
 434:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 435:mri/core/cmd_vcont.c ****     Action   action;
 436:mri/core/cmd_vcont.c **** 
 437:mri/core/cmd_vcont.c ****     while (Buffer_BytesLeft(pBuffer) > 0 && Buffer_IsNextCharEqualTo(pBuffer, ';'))
 438:mri/core/cmd_vcont.c ****     {
 439:mri/core/cmd_vcont.c ****         action = parseAction(pBuffer);
 440:mri/core/cmd_vcont.c ****         returnValue |= handleActionWithSetThreadState(&action);
 441:mri/core/cmd_vcont.c ****     }
 442:mri/core/cmd_vcont.c ****     return returnValue;
 443:mri/core/cmd_vcont.c **** }
 444:mri/core/cmd_vcont.c **** 
 445:mri/core/cmd_vcont.c **** static uint32_t handleActionWithSetThreadState(const Action* pAction)
 446:mri/core/cmd_vcont.c **** {
 447:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 448:mri/core/cmd_vcont.c ****     uint32_t threadId = getThreadIdFromAction(pAction);
 449:mri/core/cmd_vcont.c **** 
 450:mri/core/cmd_vcont.c ****     switch (pAction->type)
 451:mri/core/cmd_vcont.c ****     {
 452:mri/core/cmd_vcont.c ****         case ACTION_CONTINUE:
 453:mri/core/cmd_vcont.c ****             Platform_RtosSetThreadState(threadId, MRI_PLATFORM_THREAD_THAWED);
 454:mri/core/cmd_vcont.c ****             returnValue = HANDLER_RETURN_RESUME_PROGRAM | HANDLER_RETURN_RETURN_IMMEDIATELY;
 455:mri/core/cmd_vcont.c ****             break;
 456:mri/core/cmd_vcont.c ****         case ACTION_SINGLE_STEP:
 457:mri/core/cmd_vcont.c ****             Platform_RtosSetThreadState(threadId, MRI_PLATFORM_THREAD_SINGLE_STEPPING);
 458:mri/core/cmd_vcont.c ****             Platform_EnableSingleStep();
 459:mri/core/cmd_vcont.c ****             returnValue = HANDLER_RETURN_RESUME_PROGRAM | HANDLER_RETURN_RETURN_IMMEDIATELY;
 460:mri/core/cmd_vcont.c ****             break;
 461:mri/core/cmd_vcont.c ****         case ACTION_RANGED_SINGLE_STEP:
 462:mri/core/cmd_vcont.c ****             Platform_RtosSetThreadState(threadId, MRI_PLATFORM_THREAD_SINGLE_STEPPING);
 463:mri/core/cmd_vcont.c ****             Platform_EnableSingleStep();
 464:mri/core/cmd_vcont.c ****             SetSingleSteppingRange(&pAction->range);
 465:mri/core/cmd_vcont.c ****             returnValue = HANDLER_RETURN_RESUME_PROGRAM | HANDLER_RETURN_RETURN_IMMEDIATELY;
ARM GAS  /tmp/ccX6djba.s 			page 10


 466:mri/core/cmd_vcont.c ****             break;
 467:mri/core/cmd_vcont.c ****         default:
 468:mri/core/cmd_vcont.c ****             break;
 469:mri/core/cmd_vcont.c ****    }
 470:mri/core/cmd_vcont.c ****    return returnValue;
 471:mri/core/cmd_vcont.c **** }
 472:mri/core/cmd_vcont.c **** 
 473:mri/core/cmd_vcont.c **** static uint32_t getThreadIdFromAction(const Action* pAction)
 474:mri/core/cmd_vcont.c **** {
  52              		.loc 1 474 1 is_stmt 1 view -0
  53              		.cfi_startproc
  54              		@ args = 0, pretend = 0, frame = 0
  55              		@ frame_needed = 0, uses_anonymous_args = 0
  56              		@ link register save eliminated.
 475:mri/core/cmd_vcont.c ****     uint32_t threadId = 0;
  57              		.loc 1 475 5 view .LVU5
 476:mri/core/cmd_vcont.c ****     switch (pAction->threadId.type)
  58              		.loc 1 476 5 view .LVU6
  59              		.loc 1 476 30 is_stmt 0 view .LVU7
  60 0000 90F90430 		ldrsb	r3, [r0, #4]
  61              		.loc 1 476 5 view .LVU8
  62 0004 5BB1     		cbz	r3, .L5
  63 0006 012B     		cmp	r3, #1
  64 0008 07D0     		beq	.L4
  65 000a B3F1FF3F 		cmp	r3, #-1
  66 000e 01D0     		beq	.L7
  67 0010 0020     		movs	r0, #0
  68              	.LVL3:
 477:mri/core/cmd_vcont.c ****     {
 478:mri/core/cmd_vcont.c ****         case THREAD_ID_NONE:
 479:mri/core/cmd_vcont.c ****             threadId = MRI_PLATFORM_ALL_FROZEN_THREADS;
 480:mri/core/cmd_vcont.c ****             break;
 481:mri/core/cmd_vcont.c ****         case THREAD_ID_ALL:
 482:mri/core/cmd_vcont.c ****             threadId = MRI_PLATFORM_ALL_THREADS;
 483:mri/core/cmd_vcont.c ****             break;
 484:mri/core/cmd_vcont.c ****         case THREAD_ID_SPECIFIC:
 485:mri/core/cmd_vcont.c ****             threadId = pAction->threadId.id;
 486:mri/core/cmd_vcont.c ****             break;
 487:mri/core/cmd_vcont.c ****     }
 488:mri/core/cmd_vcont.c ****     return threadId;
  69              		.loc 1 488 5 is_stmt 1 view .LVU9
 489:mri/core/cmd_vcont.c **** }
  70              		.loc 1 489 1 is_stmt 0 view .LVU10
  71 0012 7047     		bx	lr
  72              	.LVL4:
  73              	.L7:
 482:mri/core/cmd_vcont.c ****             break;
  74              		.loc 1 482 22 view .LVU11
  75 0014 4FF0FF30 		mov	r0, #-1
  76              	.LVL5:
 482:mri/core/cmd_vcont.c ****             break;
  77              		.loc 1 482 22 view .LVU12
  78 0018 7047     		bx	lr
  79              	.LVL6:
  80              	.L4:
 485:mri/core/cmd_vcont.c ****             break;
  81              		.loc 1 485 13 is_stmt 1 view .LVU13
ARM GAS  /tmp/ccX6djba.s 			page 11


 485:mri/core/cmd_vcont.c ****             break;
  82              		.loc 1 485 22 is_stmt 0 view .LVU14
  83 001a 0068     		ldr	r0, [r0]
  84              	.LVL7:
 486:mri/core/cmd_vcont.c ****     }
  85              		.loc 1 486 13 is_stmt 1 view .LVU15
  86 001c 7047     		bx	lr
  87              	.LVL8:
  88              	.L5:
 479:mri/core/cmd_vcont.c ****             break;
  89              		.loc 1 479 22 is_stmt 0 view .LVU16
  90 001e 6FF00100 		mvn	r0, #1
  91              	.LVL9:
 479:mri/core/cmd_vcont.c ****             break;
  92              		.loc 1 479 22 view .LVU17
  93 0022 7047     		bx	lr
  94              		.cfi_endproc
  95              	.LFE25:
  97              		.section	.rodata.handleVContQueryCommand.str1.4,"aMS",%progbits,1
  98              		.align	2
  99              	.LC0:
 100 0000 76436F6E 		.ascii	"vCont;c;C;s;S;r\000"
 100      743B633B 
 100      433B733B 
 100      533B7200 
 101              		.section	.text.handleVContQueryCommand,"ax",%progbits
 102              		.align	1
 103              		.syntax unified
 104              		.thumb
 105              		.thumb_func
 107              	handleVContQueryCommand:
 108              	.LFB4:
 109:mri/core/cmd_vcont.c ****     Buffer* pBuffer = GetInitializedBuffer();
 109              		.loc 1 109 1 is_stmt 1 view -0
 110              		.cfi_startproc
 111              		@ args = 0, pretend = 0, frame = 0
 112              		@ frame_needed = 0, uses_anonymous_args = 0
 113 0000 08B5     		push	{r3, lr}
 114              	.LCFI0:
 115              		.cfi_def_cfa_offset 8
 116              		.cfi_offset 3, -8
 117              		.cfi_offset 14, -4
 110:mri/core/cmd_vcont.c ****     Buffer_WriteString(pBuffer, "vCont;c;C;s;S;r");
 118              		.loc 1 110 5 view .LVU19
 110:mri/core/cmd_vcont.c ****     Buffer_WriteString(pBuffer, "vCont;c;C;s;S;r");
 119              		.loc 1 110 23 is_stmt 0 view .LVU20
 120 0002 FFF7FEFF 		bl	mriCore_GetInitializedBuffer
 121              	.LVL10:
 111:mri/core/cmd_vcont.c ****     return 0;
 122              		.loc 1 111 5 is_stmt 1 view .LVU21
 123 0006 0249     		ldr	r1, .L10
 124 0008 FFF7FEFF 		bl	mriBuffer_WriteString
 125              	.LVL11:
 112:mri/core/cmd_vcont.c **** }
 126              		.loc 1 112 5 view .LVU22
 113:mri/core/cmd_vcont.c **** 
 127              		.loc 1 113 1 is_stmt 0 view .LVU23
ARM GAS  /tmp/ccX6djba.s 			page 12


 128 000c 0020     		movs	r0, #0
 129 000e 08BD     		pop	{r3, pc}
 130              	.L11:
 131              		.align	2
 132              	.L10:
 133 0010 00000000 		.word	.LC0
 134              		.cfi_endproc
 135              	.LFE4:
 137              		.section	.text.parseOptionalThreadId,"ax",%progbits
 138              		.align	1
 139              		.syntax unified
 140              		.thumb
 141              		.thumb_func
 143              	parseOptionalThreadId:
 144              	.LVL12:
 145              	.LFB18:
 347:mri/core/cmd_vcont.c ****     static const char negativeOne[] = "-1";
 146              		.loc 1 347 1 is_stmt 1 view -0
 147              		.cfi_startproc
 148              		@ args = 0, pretend = 0, frame = 0
 149              		@ frame_needed = 0, uses_anonymous_args = 0
 347:mri/core/cmd_vcont.c ****     static const char negativeOne[] = "-1";
 150              		.loc 1 347 1 is_stmt 0 view .LVU25
 151 0000 70B5     		push	{r4, r5, r6, lr}
 152              	.LCFI1:
 153              		.cfi_def_cfa_offset 16
 154              		.cfi_offset 4, -16
 155              		.cfi_offset 5, -12
 156              		.cfi_offset 6, -8
 157              		.cfi_offset 14, -4
 158 0002 0446     		mov	r4, r0
 159 0004 0D46     		mov	r5, r1
 348:mri/core/cmd_vcont.c ****     ThreadId          threadId = { 0, THREAD_ID_NONE };
 160              		.loc 1 348 5 is_stmt 1 view .LVU26
 349:mri/core/cmd_vcont.c **** 
 161              		.loc 1 349 5 view .LVU27
 349:mri/core/cmd_vcont.c **** 
 162              		.loc 1 349 23 is_stmt 0 view .LVU28
 163 0006 0023     		movs	r3, #0
 164 0008 0360     		str	r3, [r0]
 165 000a 0371     		strb	r3, [r0, #4]
 351:mri/core/cmd_vcont.c ****         return threadId;
 166              		.loc 1 351 5 is_stmt 1 view .LVU29
 351:mri/core/cmd_vcont.c ****         return threadId;
 167              		.loc 1 351 9 is_stmt 0 view .LVU30
 168 000c 0846     		mov	r0, r1
 169              	.LVL13:
 351:mri/core/cmd_vcont.c ****         return threadId;
 170              		.loc 1 351 9 view .LVU31
 171 000e FFF7FEFF 		bl	mriBuffer_BytesLeft
 172              	.LVL14:
 351:mri/core/cmd_vcont.c ****         return threadId;
 173              		.loc 1 351 8 view .LVU32
 174 0012 08B9     		cbnz	r0, .L19
 175              	.L12:
 371:mri/core/cmd_vcont.c **** 
 176              		.loc 1 371 1 view .LVU33
ARM GAS  /tmp/ccX6djba.s 			page 13


 177 0014 2046     		mov	r0, r4
 178 0016 70BD     		pop	{r4, r5, r6, pc}
 179              	.LVL15:
 180              	.L19:
 351:mri/core/cmd_vcont.c ****         return threadId;
 181              		.loc 1 351 44 discriminator 1 view .LVU34
 182 0018 3A21     		movs	r1, #58
 183 001a 2846     		mov	r0, r5
 184 001c FFF7FEFF 		bl	mriBuffer_IsNextCharEqualTo
 185              	.LVL16:
 351:mri/core/cmd_vcont.c ****         return threadId;
 186              		.loc 1 351 40 discriminator 1 view .LVU35
 187 0020 0028     		cmp	r0, #0
 188 0022 F7D0     		beq	.L12
 354:mri/core/cmd_vcont.c ****     {
 189              		.loc 1 354 5 is_stmt 1 view .LVU36
 354:mri/core/cmd_vcont.c ****     {
 190              		.loc 1 354 9 is_stmt 0 view .LVU37
 191 0024 0222     		movs	r2, #2
 192 0026 0A49     		ldr	r1, .L20
 193 0028 2846     		mov	r0, r5
 194 002a FFF7FEFF 		bl	mriBuffer_MatchesString
 195              	.LVL17:
 354:mri/core/cmd_vcont.c ****     {
 196              		.loc 1 354 8 view .LVU38
 197 002e 10B1     		cbz	r0, .L16
 356:mri/core/cmd_vcont.c ****         return threadId;
 198              		.loc 1 356 9 is_stmt 1 view .LVU39
 356:mri/core/cmd_vcont.c ****         return threadId;
 199              		.loc 1 356 23 is_stmt 0 view .LVU40
 200 0030 FF23     		movs	r3, #255
 201 0032 2371     		strb	r3, [r4, #4]
 357:mri/core/cmd_vcont.c ****     }
 202              		.loc 1 357 9 is_stmt 1 view .LVU41
 357:mri/core/cmd_vcont.c ****     }
 203              		.loc 1 357 16 is_stmt 0 view .LVU42
 204 0034 EEE7     		b	.L12
 205              	.L16:
 360:mri/core/cmd_vcont.c ****     {
 206              		.loc 1 360 5 is_stmt 1 view .LVU43
 360:mri/core/cmd_vcont.c ****     {
 207              		.loc 1 360 5 view .LVU44
 208              	.LBB24:
 209              	.LBI24:
 210              		.file 2 "mri/core/try_catch.h"
   1:mri/core/try_catch.h **** /* Copyright 2014 Adam Green (https://github.com/adamgreen/)
   2:mri/core/try_catch.h **** 
   3:mri/core/try_catch.h ****    Licensed under the Apache License, Version 2.0 (the "License");
   4:mri/core/try_catch.h ****    you may not use this file except in compliance with the License.
   5:mri/core/try_catch.h ****    You may obtain a copy of the License at
   6:mri/core/try_catch.h **** 
   7:mri/core/try_catch.h ****        http://www.apache.org/licenses/LICENSE-2.0
   8:mri/core/try_catch.h **** 
   9:mri/core/try_catch.h ****    Unless required by applicable law or agreed to in writing, software
  10:mri/core/try_catch.h ****    distributed under the License is distributed on an "AS IS" BASIS,
  11:mri/core/try_catch.h ****    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  12:mri/core/try_catch.h ****    See the License for the specific language governing permissions and
ARM GAS  /tmp/ccX6djba.s 			page 14


  13:mri/core/try_catch.h ****    limitations under the License.
  14:mri/core/try_catch.h **** */
  15:mri/core/try_catch.h **** /* Very rough exception handling like macros for C. */
  16:mri/core/try_catch.h **** #ifndef MRI_TRY_CATCH_H_
  17:mri/core/try_catch.h **** #define MRI_TRY_CATCH_H_
  18:mri/core/try_catch.h **** 
  19:mri/core/try_catch.h **** #define noException                         0
  20:mri/core/try_catch.h **** #define bufferOverrunException              1
  21:mri/core/try_catch.h **** #define invalidHexDigitException            2
  22:mri/core/try_catch.h **** #define invalidValueException               3
  23:mri/core/try_catch.h **** #define invalidArgumentException            4
  24:mri/core/try_catch.h **** #define timeoutException                    5
  25:mri/core/try_catch.h **** #define invalidIndexException               6
  26:mri/core/try_catch.h **** #define notFoundException                   7
  27:mri/core/try_catch.h **** #define exceededHardwareResourcesException  8
  28:mri/core/try_catch.h **** #define invalidDecDigitException            9
  29:mri/core/try_catch.h **** #define memFaultException                   10
  30:mri/core/try_catch.h **** #define mriMaxException                     15
  31:mri/core/try_catch.h **** 
  32:mri/core/try_catch.h **** extern int mriExceptionCode;
  33:mri/core/try_catch.h **** 
  34:mri/core/try_catch.h **** 
  35:mri/core/try_catch.h **** /* Allow an application including MRI to extend with their own exception codes and replace the belo
  36:mri/core/try_catch.h **** #ifndef MRI_SKIP_TRY_CATCH_MACRO_DEFINES
  37:mri/core/try_catch.h **** 
  38:mri/core/try_catch.h **** /* On Linux, it is possible that __try and __catch are already defined. */
  39:mri/core/try_catch.h **** #undef __try
  40:mri/core/try_catch.h **** #undef __catch
  41:mri/core/try_catch.h **** 
  42:mri/core/try_catch.h **** #define __throws
  43:mri/core/try_catch.h **** 
  44:mri/core/try_catch.h **** #define __try \
  45:mri/core/try_catch.h ****         do \
  46:mri/core/try_catch.h ****         { \
  47:mri/core/try_catch.h ****             clearExceptionCode();
  48:mri/core/try_catch.h **** 
  49:mri/core/try_catch.h **** #define __throwing_func(X) \
  50:mri/core/try_catch.h ****             X; \
  51:mri/core/try_catch.h ****             if (mriExceptionCode) \
  52:mri/core/try_catch.h ****                 break;
  53:mri/core/try_catch.h **** 
  54:mri/core/try_catch.h **** #define __catch \
  55:mri/core/try_catch.h ****         } while (0); \
  56:mri/core/try_catch.h ****         if (mriExceptionCode)
  57:mri/core/try_catch.h **** 
  58:mri/core/try_catch.h **** #define __throw(EXCEPTION) return ((void)setExceptionCode(EXCEPTION))
  59:mri/core/try_catch.h **** 
  60:mri/core/try_catch.h **** #define __throw_and_return(EXCEPTION, RETURN) return (setExceptionCode(EXCEPTION), (RETURN))
  61:mri/core/try_catch.h **** 
  62:mri/core/try_catch.h **** #define __rethrow return
  63:mri/core/try_catch.h **** 
  64:mri/core/try_catch.h **** #define __rethrow_and_return(RETURN) return RETURN
  65:mri/core/try_catch.h **** 
  66:mri/core/try_catch.h **** static inline int getExceptionCode(void)
  67:mri/core/try_catch.h **** {
  68:mri/core/try_catch.h ****     return mriExceptionCode;
  69:mri/core/try_catch.h **** }
ARM GAS  /tmp/ccX6djba.s 			page 15


  70:mri/core/try_catch.h **** 
  71:mri/core/try_catch.h **** static inline void setExceptionCode(int exceptionCode)
  72:mri/core/try_catch.h **** {
  73:mri/core/try_catch.h ****     mriExceptionCode = exceptionCode > mriExceptionCode ? exceptionCode : mriExceptionCode;
  74:mri/core/try_catch.h **** }
  75:mri/core/try_catch.h **** 
  76:mri/core/try_catch.h **** static inline void clearExceptionCode(void)
 211              		.loc 2 76 20 view .LVU45
 212              	.LBB25:
  77:mri/core/try_catch.h **** {
  78:mri/core/try_catch.h ****     mriExceptionCode = noException;
 213              		.loc 2 78 5 view .LVU46
 214              		.loc 2 78 22 is_stmt 0 view .LVU47
 215 0036 074E     		ldr	r6, .L20+4
 216 0038 0023     		movs	r3, #0
 217 003a 3360     		str	r3, [r6]
 218              	.LBE25:
 219              	.LBE24:
 362:mri/core/cmd_vcont.c ****         threadId.type = THREAD_ID_SPECIFIC;
 220              		.loc 1 362 9 is_stmt 1 view .LVU48
 221 003c 2846     		mov	r0, r5
 222 003e FFF7FEFF 		bl	mriBuffer_ReadUIntegerAsHex
 223              	.LVL18:
 224 0042 2060     		str	r0, [r4]
 362:mri/core/cmd_vcont.c ****         threadId.type = THREAD_ID_SPECIFIC;
 225              		.loc 1 362 9 view .LVU49
 226 0044 3368     		ldr	r3, [r6]
 227 0046 002B     		cmp	r3, #0
 228 0048 E4D1     		bne	.L12
 362:mri/core/cmd_vcont.c ****         threadId.type = THREAD_ID_SPECIFIC;
 229              		.loc 1 362 75 discriminator 1 view .LVU50
 363:mri/core/cmd_vcont.c ****     }
 230              		.loc 1 363 9 discriminator 1 view .LVU51
 363:mri/core/cmd_vcont.c ****     }
 231              		.loc 1 363 23 is_stmt 0 discriminator 1 view .LVU52
 232 004a 0123     		movs	r3, #1
 233 004c 2371     		strb	r3, [r4, #4]
 360:mri/core/cmd_vcont.c ****     {
 234              		.loc 1 360 5 is_stmt 1 discriminator 1 view .LVU53
 365:mri/core/cmd_vcont.c ****     {
 235              		.loc 1 365 5 discriminator 1 view .LVU54
 236 004e E1E7     		b	.L12
 237              	.L21:
 238              		.align	2
 239              	.L20:
 240 0050 00000000 		.word	negativeOne.0
 241 0054 00000000 		.word	mriExceptionCode
 242              		.cfi_endproc
 243              	.LFE18:
 245              		.section	.text.parseContinueAction,"ax",%progbits
 246              		.align	1
 247              		.syntax unified
 248              		.thumb
 249              		.thumb_func
 251              	parseContinueAction:
 252              	.LVL19:
 253              	.LFB12:
ARM GAS  /tmp/ccX6djba.s 			page 16


 267:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_CONTINUE };
 254              		.loc 1 267 1 view -0
 255              		.cfi_startproc
 256              		@ args = 0, pretend = 0, frame = 8
 257              		@ frame_needed = 0, uses_anonymous_args = 0
 267:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_CONTINUE };
 258              		.loc 1 267 1 is_stmt 0 view .LVU56
 259 0000 30B5     		push	{r4, r5, lr}
 260              	.LCFI2:
 261              		.cfi_def_cfa_offset 12
 262              		.cfi_offset 4, -12
 263              		.cfi_offset 5, -8
 264              		.cfi_offset 14, -4
 265 0002 83B0     		sub	sp, sp, #12
 266              	.LCFI3:
 267              		.cfi_def_cfa_offset 24
 268 0004 0446     		mov	r4, r0
 268:mri/core/cmd_vcont.c ****     action.threadId  = parseOptionalThreadId(pBuffer);
 269              		.loc 1 268 5 is_stmt 1 view .LVU57
 268:mri/core/cmd_vcont.c ****     action.threadId  = parseOptionalThreadId(pBuffer);
 270              		.loc 1 268 12 is_stmt 0 view .LVU58
 271 0006 0023     		movs	r3, #0
 272 0008 0360     		str	r3, [r0]
 273 000a 0371     		strb	r3, [r0, #4]
 274 000c 8360     		str	r3, [r0, #8]
 275 000e C360     		str	r3, [r0, #12]
 276 0010 0123     		movs	r3, #1
 277 0012 0374     		strb	r3, [r0, #16]
 269:mri/core/cmd_vcont.c ****     return action;
 278              		.loc 1 269 5 is_stmt 1 view .LVU59
 269:mri/core/cmd_vcont.c ****     return action;
 279              		.loc 1 269 24 is_stmt 0 view .LVU60
 280 0014 6D46     		mov	r5, sp
 281 0016 2846     		mov	r0, r5
 282              	.LVL20:
 269:mri/core/cmd_vcont.c ****     return action;
 283              		.loc 1 269 24 view .LVU61
 284 0018 FFF7FEFF 		bl	parseOptionalThreadId
 285              	.LVL21:
 269:mri/core/cmd_vcont.c ****     return action;
 286              		.loc 1 269 24 view .LVU62
 287 001c 95E80300 		ldm	r5, {r0, r1}
 288 0020 84E80300 		stm	r4, {r0, r1}
 270:mri/core/cmd_vcont.c **** }
 289              		.loc 1 270 5 is_stmt 1 view .LVU63
 271:mri/core/cmd_vcont.c **** 
 290              		.loc 1 271 1 is_stmt 0 view .LVU64
 291 0024 2046     		mov	r0, r4
 292 0026 03B0     		add	sp, sp, #12
 293              	.LCFI4:
 294              		.cfi_def_cfa_offset 12
 295              		@ sp needed
 296 0028 30BD     		pop	{r4, r5, pc}
 271:mri/core/cmd_vcont.c **** 
 297              		.loc 1 271 1 view .LVU65
 298              		.cfi_endproc
 299              	.LFE12:
ARM GAS  /tmp/ccX6djba.s 			page 17


 301              		.section	.text.parseSingleStepAction,"ax",%progbits
 302              		.align	1
 303              		.syntax unified
 304              		.thumb
 305              		.thumb_func
 307              	parseSingleStepAction:
 308              	.LVL22:
 309              	.LFB14:
 291:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_SINGLE_STEP };
 310              		.loc 1 291 1 is_stmt 1 view -0
 311              		.cfi_startproc
 312              		@ args = 0, pretend = 0, frame = 8
 313              		@ frame_needed = 0, uses_anonymous_args = 0
 291:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_SINGLE_STEP };
 314              		.loc 1 291 1 is_stmt 0 view .LVU67
 315 0000 30B5     		push	{r4, r5, lr}
 316              	.LCFI5:
 317              		.cfi_def_cfa_offset 12
 318              		.cfi_offset 4, -12
 319              		.cfi_offset 5, -8
 320              		.cfi_offset 14, -4
 321 0002 83B0     		sub	sp, sp, #12
 322              	.LCFI6:
 323              		.cfi_def_cfa_offset 24
 324 0004 0446     		mov	r4, r0
 292:mri/core/cmd_vcont.c ****     action.threadId  = parseOptionalThreadId(pBuffer);
 325              		.loc 1 292 5 is_stmt 1 view .LVU68
 292:mri/core/cmd_vcont.c ****     action.threadId  = parseOptionalThreadId(pBuffer);
 326              		.loc 1 292 12 is_stmt 0 view .LVU69
 327 0006 0023     		movs	r3, #0
 328 0008 0360     		str	r3, [r0]
 329 000a 0371     		strb	r3, [r0, #4]
 330 000c 8360     		str	r3, [r0, #8]
 331 000e C360     		str	r3, [r0, #12]
 332 0010 0223     		movs	r3, #2
 333 0012 0374     		strb	r3, [r0, #16]
 293:mri/core/cmd_vcont.c ****     return action;
 334              		.loc 1 293 5 is_stmt 1 view .LVU70
 293:mri/core/cmd_vcont.c ****     return action;
 335              		.loc 1 293 24 is_stmt 0 view .LVU71
 336 0014 6D46     		mov	r5, sp
 337 0016 2846     		mov	r0, r5
 338              	.LVL23:
 293:mri/core/cmd_vcont.c ****     return action;
 339              		.loc 1 293 24 view .LVU72
 340 0018 FFF7FEFF 		bl	parseOptionalThreadId
 341              	.LVL24:
 293:mri/core/cmd_vcont.c ****     return action;
 342              		.loc 1 293 24 view .LVU73
 343 001c 95E80300 		ldm	r5, {r0, r1}
 344 0020 84E80300 		stm	r4, {r0, r1}
 294:mri/core/cmd_vcont.c **** }
 345              		.loc 1 294 5 is_stmt 1 view .LVU74
 295:mri/core/cmd_vcont.c **** 
 346              		.loc 1 295 1 is_stmt 0 view .LVU75
 347 0024 2046     		mov	r0, r4
 348 0026 03B0     		add	sp, sp, #12
ARM GAS  /tmp/ccX6djba.s 			page 18


 349              	.LCFI7:
 350              		.cfi_def_cfa_offset 12
 351              		@ sp needed
 352 0028 30BD     		pop	{r4, r5, pc}
 295:mri/core/cmd_vcont.c **** 
 353              		.loc 1 295 1 view .LVU76
 354              		.cfi_endproc
 355              	.LFE14:
 357              		.section	.text.parseContinueWithSignalAction,"ax",%progbits
 358              		.align	1
 359              		.syntax unified
 360              		.thumb
 361              		.thumb_func
 363              	parseContinueWithSignalAction:
 364              	.LVL25:
 365              	.LFB13:
 274:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_CONTINUE };
 366              		.loc 1 274 1 is_stmt 1 view -0
 367              		.cfi_startproc
 368              		@ args = 0, pretend = 0, frame = 8
 369              		@ frame_needed = 0, uses_anonymous_args = 0
 274:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_CONTINUE };
 370              		.loc 1 274 1 is_stmt 0 view .LVU78
 371 0000 70B5     		push	{r4, r5, r6, lr}
 372              	.LCFI8:
 373              		.cfi_def_cfa_offset 16
 374              		.cfi_offset 4, -16
 375              		.cfi_offset 5, -12
 376              		.cfi_offset 6, -8
 377              		.cfi_offset 14, -4
 378 0002 82B0     		sub	sp, sp, #8
 379              	.LCFI9:
 380              		.cfi_def_cfa_offset 24
 381 0004 0446     		mov	r4, r0
 382 0006 0D46     		mov	r5, r1
 275:mri/core/cmd_vcont.c **** 
 383              		.loc 1 275 5 is_stmt 1 view .LVU79
 275:mri/core/cmd_vcont.c **** 
 384              		.loc 1 275 12 is_stmt 0 view .LVU80
 385 0008 0023     		movs	r3, #0
 386 000a 0360     		str	r3, [r0]
 387 000c 0371     		strb	r3, [r0, #4]
 388 000e 8360     		str	r3, [r0, #8]
 389 0010 C360     		str	r3, [r0, #12]
 390 0012 0122     		movs	r2, #1
 391 0014 0274     		strb	r2, [r0, #16]
 277:mri/core/cmd_vcont.c ****     {
 392              		.loc 1 277 5 is_stmt 1 view .LVU81
 277:mri/core/cmd_vcont.c ****     {
 393              		.loc 1 277 5 view .LVU82
 394              	.LBB26:
 395              	.LBI26:
  76:mri/core/try_catch.h **** {
 396              		.loc 2 76 20 view .LVU83
 397              	.LBB27:
 398              		.loc 2 78 5 view .LVU84
 399              		.loc 2 78 22 is_stmt 0 view .LVU85
ARM GAS  /tmp/ccX6djba.s 			page 19


 400 0016 0A4E     		ldr	r6, .L30
 401 0018 3360     		str	r3, [r6]
 402              	.LBE27:
 403              	.LBE26:
 280:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 404              		.loc 1 280 9 is_stmt 1 view .LVU86
 405 001a 0846     		mov	r0, r1
 406              	.LVL26:
 280:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 407              		.loc 1 280 9 is_stmt 0 view .LVU87
 408 001c FFF7FEFF 		bl	mriBuffer_ReadByteAsHex
 409              	.LVL27:
 280:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 410              		.loc 1 280 9 is_stmt 1 view .LVU88
 411 0020 3368     		ldr	r3, [r6]
 412 0022 13B1     		cbz	r3, .L29
 413              	.L27:
 277:mri/core/cmd_vcont.c ****     {
 414              		.loc 1 277 5 view .LVU89
 283:mri/core/cmd_vcont.c ****     {
 415              		.loc 1 283 5 view .LVU90
 288:mri/core/cmd_vcont.c **** 
 416              		.loc 1 288 1 is_stmt 0 view .LVU91
 417 0024 2046     		mov	r0, r4
 418 0026 02B0     		add	sp, sp, #8
 419              	.LCFI10:
 420              		.cfi_remember_state
 421              		.cfi_def_cfa_offset 16
 422              		@ sp needed
 423 0028 70BD     		pop	{r4, r5, r6, pc}
 424              	.LVL28:
 425              	.L29:
 426              	.LCFI11:
 427              		.cfi_restore_state
 280:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 428              		.loc 1 280 57 is_stmt 1 discriminator 1 view .LVU92
 281:mri/core/cmd_vcont.c ****     }
 429              		.loc 1 281 9 discriminator 1 view .LVU93
 281:mri/core/cmd_vcont.c ****     }
 430              		.loc 1 281 28 is_stmt 0 discriminator 1 view .LVU94
 431 002a 6E46     		mov	r6, sp
 432 002c 2946     		mov	r1, r5
 433 002e 3046     		mov	r0, r6
 434 0030 FFF7FEFF 		bl	parseOptionalThreadId
 435              	.LVL29:
 436 0034 96E80300 		ldm	r6, {r0, r1}
 437 0038 84E80300 		stm	r4, {r0, r1}
 438 003c F2E7     		b	.L27
 439              	.L31:
 440 003e 00BF     		.align	2
 441              	.L30:
 442 0040 00000000 		.word	mriExceptionCode
 443              		.cfi_endproc
 444              	.LFE13:
 446              		.section	.text.parseSingleStepWithSignalAction,"ax",%progbits
 447              		.align	1
 448              		.syntax unified
ARM GAS  /tmp/ccX6djba.s 			page 20


 449              		.thumb
 450              		.thumb_func
 452              	parseSingleStepWithSignalAction:
 453              	.LVL30:
 454              	.LFB15:
 298:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_SINGLE_STEP };
 455              		.loc 1 298 1 is_stmt 1 view -0
 456              		.cfi_startproc
 457              		@ args = 0, pretend = 0, frame = 8
 458              		@ frame_needed = 0, uses_anonymous_args = 0
 298:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_SINGLE_STEP };
 459              		.loc 1 298 1 is_stmt 0 view .LVU96
 460 0000 70B5     		push	{r4, r5, r6, lr}
 461              	.LCFI12:
 462              		.cfi_def_cfa_offset 16
 463              		.cfi_offset 4, -16
 464              		.cfi_offset 5, -12
 465              		.cfi_offset 6, -8
 466              		.cfi_offset 14, -4
 467 0002 82B0     		sub	sp, sp, #8
 468              	.LCFI13:
 469              		.cfi_def_cfa_offset 24
 470 0004 0446     		mov	r4, r0
 471 0006 0D46     		mov	r5, r1
 299:mri/core/cmd_vcont.c ****     __try
 472              		.loc 1 299 5 is_stmt 1 view .LVU97
 299:mri/core/cmd_vcont.c ****     __try
 473              		.loc 1 299 12 is_stmt 0 view .LVU98
 474 0008 0023     		movs	r3, #0
 475 000a 0360     		str	r3, [r0]
 476 000c 0371     		strb	r3, [r0, #4]
 477 000e 8360     		str	r3, [r0, #8]
 478 0010 C360     		str	r3, [r0, #12]
 479 0012 0222     		movs	r2, #2
 480 0014 0274     		strb	r2, [r0, #16]
 300:mri/core/cmd_vcont.c ****     {
 481              		.loc 1 300 5 is_stmt 1 view .LVU99
 300:mri/core/cmd_vcont.c ****     {
 482              		.loc 1 300 5 view .LVU100
 483              	.LBB28:
 484              	.LBI28:
  76:mri/core/try_catch.h **** {
 485              		.loc 2 76 20 view .LVU101
 486              	.LBB29:
 487              		.loc 2 78 5 view .LVU102
 488              		.loc 2 78 22 is_stmt 0 view .LVU103
 489 0016 0A4E     		ldr	r6, .L36
 490 0018 3360     		str	r3, [r6]
 491              	.LBE29:
 492              	.LBE28:
 303:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 493              		.loc 1 303 9 is_stmt 1 view .LVU104
 494 001a 0846     		mov	r0, r1
 495              	.LVL31:
 303:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 496              		.loc 1 303 9 is_stmt 0 view .LVU105
 497 001c FFF7FEFF 		bl	mriBuffer_ReadByteAsHex
ARM GAS  /tmp/ccX6djba.s 			page 21


 498              	.LVL32:
 303:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 499              		.loc 1 303 9 is_stmt 1 view .LVU106
 500 0020 3368     		ldr	r3, [r6]
 501 0022 13B1     		cbz	r3, .L35
 502              	.L33:
 300:mri/core/cmd_vcont.c ****     {
 503              		.loc 1 300 5 view .LVU107
 306:mri/core/cmd_vcont.c ****     {
 504              		.loc 1 306 5 view .LVU108
 311:mri/core/cmd_vcont.c **** 
 505              		.loc 1 311 1 is_stmt 0 view .LVU109
 506 0024 2046     		mov	r0, r4
 507 0026 02B0     		add	sp, sp, #8
 508              	.LCFI14:
 509              		.cfi_remember_state
 510              		.cfi_def_cfa_offset 16
 511              		@ sp needed
 512 0028 70BD     		pop	{r4, r5, r6, pc}
 513              	.LVL33:
 514              	.L35:
 515              	.LCFI15:
 516              		.cfi_restore_state
 303:mri/core/cmd_vcont.c ****         action.threadId  = parseOptionalThreadId(pBuffer);
 517              		.loc 1 303 57 is_stmt 1 discriminator 1 view .LVU110
 304:mri/core/cmd_vcont.c ****     }
 518              		.loc 1 304 9 discriminator 1 view .LVU111
 304:mri/core/cmd_vcont.c ****     }
 519              		.loc 1 304 28 is_stmt 0 discriminator 1 view .LVU112
 520 002a 6E46     		mov	r6, sp
 521 002c 2946     		mov	r1, r5
 522 002e 3046     		mov	r0, r6
 523 0030 FFF7FEFF 		bl	parseOptionalThreadId
 524              	.LVL34:
 525 0034 96E80300 		ldm	r6, {r0, r1}
 526 0038 84E80300 		stm	r4, {r0, r1}
 527 003c F2E7     		b	.L33
 528              	.L37:
 529 003e 00BF     		.align	2
 530              	.L36:
 531 0040 00000000 		.word	mriExceptionCode
 532              		.cfi_endproc
 533              	.LFE15:
 535              		.section	.text.parseAddressRange,"ax",%progbits
 536              		.align	1
 537              		.syntax unified
 538              		.thumb
 539              		.thumb_func
 541              	parseAddressRange:
 542              	.LVL35:
 543              	.LFB17:
 331:mri/core/cmd_vcont.c ****     AddressRange range = {0, 0};
 544              		.loc 1 331 1 is_stmt 1 view -0
 545              		.cfi_startproc
 546              		@ args = 0, pretend = 0, frame = 0
 547              		@ frame_needed = 0, uses_anonymous_args = 0
 331:mri/core/cmd_vcont.c ****     AddressRange range = {0, 0};
ARM GAS  /tmp/ccX6djba.s 			page 22


 548              		.loc 1 331 1 is_stmt 0 view .LVU114
 549 0000 70B5     		push	{r4, r5, r6, lr}
 550              	.LCFI16:
 551              		.cfi_def_cfa_offset 16
 552              		.cfi_offset 4, -16
 553              		.cfi_offset 5, -12
 554              		.cfi_offset 6, -8
 555              		.cfi_offset 14, -4
 556 0002 0446     		mov	r4, r0
 557 0004 0D46     		mov	r5, r1
 332:mri/core/cmd_vcont.c ****     __try
 558              		.loc 1 332 5 is_stmt 1 view .LVU115
 332:mri/core/cmd_vcont.c ****     __try
 559              		.loc 1 332 18 is_stmt 0 view .LVU116
 560 0006 0023     		movs	r3, #0
 561 0008 0360     		str	r3, [r0]
 562 000a 4360     		str	r3, [r0, #4]
 333:mri/core/cmd_vcont.c ****     {
 563              		.loc 1 333 5 is_stmt 1 view .LVU117
 333:mri/core/cmd_vcont.c ****     {
 564              		.loc 1 333 5 view .LVU118
 565              	.LBB30:
 566              	.LBI30:
  76:mri/core/try_catch.h **** {
 567              		.loc 2 76 20 view .LVU119
 568              	.LBB31:
 569              		.loc 2 78 5 view .LVU120
 570              		.loc 2 78 22 is_stmt 0 view .LVU121
 571 000c 0A4E     		ldr	r6, .L42
 572 000e 3360     		str	r3, [r6]
 573              	.LBE31:
 574              	.LBE30:
 335:mri/core/cmd_vcont.c ****         __throwing_func( ThrowIfNextCharIsNotEqualTo(pBuffer, ',') );
 575              		.loc 1 335 9 is_stmt 1 view .LVU122
 576 0010 0846     		mov	r0, r1
 577              	.LVL36:
 335:mri/core/cmd_vcont.c ****         __throwing_func( ThrowIfNextCharIsNotEqualTo(pBuffer, ',') );
 578              		.loc 1 335 9 is_stmt 0 view .LVU123
 579 0012 FFF7FEFF 		bl	mriBuffer_ReadUIntegerAsHex
 580              	.LVL37:
 335:mri/core/cmd_vcont.c ****         __throwing_func( ThrowIfNextCharIsNotEqualTo(pBuffer, ',') );
 581              		.loc 1 335 9 view .LVU124
 582 0016 2060     		str	r0, [r4]
 335:mri/core/cmd_vcont.c ****         __throwing_func( ThrowIfNextCharIsNotEqualTo(pBuffer, ',') );
 583              		.loc 1 335 9 is_stmt 1 view .LVU125
 584 0018 3368     		ldr	r3, [r6]
 585 001a 0BB1     		cbz	r3, .L41
 586              	.L39:
 337:mri/core/cmd_vcont.c ****     }
 587              		.loc 1 337 73 discriminator 1 view .LVU126
 333:mri/core/cmd_vcont.c ****     {
 588              		.loc 1 333 5 discriminator 1 view .LVU127
 339:mri/core/cmd_vcont.c ****     {
 589              		.loc 1 339 5 discriminator 1 view .LVU128
 344:mri/core/cmd_vcont.c **** 
 590              		.loc 1 344 1 is_stmt 0 discriminator 1 view .LVU129
 591 001c 2046     		mov	r0, r4
ARM GAS  /tmp/ccX6djba.s 			page 23


 592 001e 70BD     		pop	{r4, r5, r6, pc}
 593              	.LVL38:
 594              	.L41:
 335:mri/core/cmd_vcont.c ****         __throwing_func( ThrowIfNextCharIsNotEqualTo(pBuffer, ',') );
 595              		.loc 1 335 75 is_stmt 1 discriminator 1 view .LVU130
 336:mri/core/cmd_vcont.c ****         __throwing_func( range.end = Buffer_ReadUIntegerAsHex(pBuffer) );
 596              		.loc 1 336 9 discriminator 1 view .LVU131
 597 0020 2C21     		movs	r1, #44
 598 0022 2846     		mov	r0, r5
 599 0024 FFF7FEFF 		bl	mriCmd_ThrowIfNextCharIsNotEqualTo
 600              	.LVL39:
 336:mri/core/cmd_vcont.c ****         __throwing_func( range.end = Buffer_ReadUIntegerAsHex(pBuffer) );
 601              		.loc 1 336 9 discriminator 1 view .LVU132
 602 0028 3368     		ldr	r3, [r6]
 603 002a 002B     		cmp	r3, #0
 604 002c F6D1     		bne	.L39
 336:mri/core/cmd_vcont.c ****         __throwing_func( range.end = Buffer_ReadUIntegerAsHex(pBuffer) );
 605              		.loc 1 336 69 discriminator 1 view .LVU133
 337:mri/core/cmd_vcont.c ****     }
 606              		.loc 1 337 9 discriminator 1 view .LVU134
 607 002e 2846     		mov	r0, r5
 608 0030 FFF7FEFF 		bl	mriBuffer_ReadUIntegerAsHex
 609              	.LVL40:
 610 0034 6060     		str	r0, [r4, #4]
 337:mri/core/cmd_vcont.c ****     }
 611              		.loc 1 337 9 discriminator 1 view .LVU135
 612 0036 F1E7     		b	.L39
 613              	.L43:
 614              		.align	2
 615              	.L42:
 616 0038 00000000 		.word	mriExceptionCode
 617              		.cfi_endproc
 618              	.LFE17:
 620              		.section	.text.parseRangedSingleStepAction,"ax",%progbits
 621              		.align	1
 622              		.syntax unified
 623              		.thumb
 624              		.thumb_func
 626              	parseRangedSingleStepAction:
 627              	.LVL41:
 628              	.LFB16:
 314:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_RANGED_SINGLE_STEP };
 629              		.loc 1 314 1 view -0
 630              		.cfi_startproc
 631              		@ args = 0, pretend = 0, frame = 16
 632              		@ frame_needed = 0, uses_anonymous_args = 0
 314:mri/core/cmd_vcont.c ****     Action action = { {THREAD_ID_NONE, 0}, {0, 0}, ACTION_RANGED_SINGLE_STEP };
 633              		.loc 1 314 1 is_stmt 0 view .LVU137
 634 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 635              	.LCFI17:
 636              		.cfi_def_cfa_offset 20
 637              		.cfi_offset 4, -20
 638              		.cfi_offset 5, -16
 639              		.cfi_offset 6, -12
 640              		.cfi_offset 7, -8
 641              		.cfi_offset 14, -4
 642 0002 85B0     		sub	sp, sp, #20
ARM GAS  /tmp/ccX6djba.s 			page 24


 643              	.LCFI18:
 644              		.cfi_def_cfa_offset 40
 645 0004 0446     		mov	r4, r0
 646 0006 0F46     		mov	r7, r1
 315:mri/core/cmd_vcont.c ****     AddressRange range = { 0, 0 };
 647              		.loc 1 315 5 is_stmt 1 view .LVU138
 315:mri/core/cmd_vcont.c ****     AddressRange range = { 0, 0 };
 648              		.loc 1 315 12 is_stmt 0 view .LVU139
 649 0008 0023     		movs	r3, #0
 650 000a 0360     		str	r3, [r0]
 651 000c 0371     		strb	r3, [r0, #4]
 652 000e 8360     		str	r3, [r0, #8]
 653 0010 C360     		str	r3, [r0, #12]
 654 0012 0322     		movs	r2, #3
 655 0014 0274     		strb	r2, [r0, #16]
 316:mri/core/cmd_vcont.c ****     __try
 656              		.loc 1 316 5 is_stmt 1 view .LVU140
 316:mri/core/cmd_vcont.c ****     __try
 657              		.loc 1 316 18 is_stmt 0 view .LVU141
 658 0016 0293     		str	r3, [sp, #8]
 659 0018 0393     		str	r3, [sp, #12]
 317:mri/core/cmd_vcont.c ****     {
 660              		.loc 1 317 5 is_stmt 1 view .LVU142
 317:mri/core/cmd_vcont.c ****     {
 661              		.loc 1 317 5 view .LVU143
 662              	.LBB32:
 663              	.LBI32:
  76:mri/core/try_catch.h **** {
 664              		.loc 2 76 20 view .LVU144
 665              	.LBB33:
 666              		.loc 2 78 5 view .LVU145
 667              		.loc 2 78 22 is_stmt 0 view .LVU146
 668 001a 0D4E     		ldr	r6, .L48
 669 001c 3360     		str	r3, [r6]
 670              	.LBE33:
 671              	.LBE32:
 319:mri/core/cmd_vcont.c ****         __throwing_func( action.threadId  = parseOptionalThreadId(pBuffer) );
 672              		.loc 1 319 9 is_stmt 1 view .LVU147
 673 001e 6D46     		mov	r5, sp
 674 0020 2846     		mov	r0, r5
 675              	.LVL42:
 319:mri/core/cmd_vcont.c ****         __throwing_func( action.threadId  = parseOptionalThreadId(pBuffer) );
 676              		.loc 1 319 9 is_stmt 0 view .LVU148
 677 0022 FFF7FEFF 		bl	parseAddressRange
 678              	.LVL43:
 319:mri/core/cmd_vcont.c ****         __throwing_func( action.threadId  = parseOptionalThreadId(pBuffer) );
 679              		.loc 1 319 9 view .LVU149
 680 0026 04F10803 		add	r3, r4, #8
 681 002a 95E80300 		ldm	r5, {r0, r1}
 682 002e 83E80300 		stm	r3, {r0, r1}
 319:mri/core/cmd_vcont.c ****         __throwing_func( action.threadId  = parseOptionalThreadId(pBuffer) );
 683              		.loc 1 319 9 is_stmt 1 view .LVU150
 684 0032 3368     		ldr	r3, [r6]
 685 0034 13B1     		cbz	r3, .L47
 686              	.L45:
 320:mri/core/cmd_vcont.c ****         (void)range;
 687              		.loc 1 320 77 discriminator 1 view .LVU151
ARM GAS  /tmp/ccX6djba.s 			page 25


 321:mri/core/cmd_vcont.c ****     }
 688              		.loc 1 321 9 discriminator 1 view .LVU152
 317:mri/core/cmd_vcont.c ****     {
 689              		.loc 1 317 5 discriminator 1 view .LVU153
 323:mri/core/cmd_vcont.c ****     {
 690              		.loc 1 323 5 discriminator 1 view .LVU154
 328:mri/core/cmd_vcont.c **** 
 691              		.loc 1 328 1 is_stmt 0 discriminator 1 view .LVU155
 692 0036 2046     		mov	r0, r4
 693 0038 05B0     		add	sp, sp, #20
 694              	.LCFI19:
 695              		.cfi_remember_state
 696              		.cfi_def_cfa_offset 20
 697              		@ sp needed
 698 003a F0BD     		pop	{r4, r5, r6, r7, pc}
 699              	.LVL44:
 700              	.L47:
 701              	.LCFI20:
 702              		.cfi_restore_state
 319:mri/core/cmd_vcont.c ****         __throwing_func( action.threadId  = parseOptionalThreadId(pBuffer) );
 703              		.loc 1 319 69 is_stmt 1 discriminator 1 view .LVU156
 320:mri/core/cmd_vcont.c ****         (void)range;
 704              		.loc 1 320 9 discriminator 1 view .LVU157
 705 003c 3946     		mov	r1, r7
 706 003e 2846     		mov	r0, r5
 707 0040 FFF7FEFF 		bl	parseOptionalThreadId
 708              	.LVL45:
 709 0044 95E80300 		ldm	r5, {r0, r1}
 710 0048 84E80300 		stm	r4, {r0, r1}
 320:mri/core/cmd_vcont.c ****         (void)range;
 711              		.loc 1 320 9 discriminator 1 view .LVU158
 712 004c F3E7     		b	.L45
 713              	.L49:
 714 004e 00BF     		.align	2
 715              	.L48:
 716 0050 00000000 		.word	mriExceptionCode
 717              		.cfi_endproc
 718              	.LFE16:
 720              		.section	.text.parseAction,"ax",%progbits
 721              		.align	1
 722              		.syntax unified
 723              		.thumb
 724              		.thumb_func
 726              	parseAction:
 727              	.LVL46:
 728              	.LFB11:
 244:mri/core/cmd_vcont.c ****     char   ch = Buffer_ReadChar(pBuffer);
 729              		.loc 1 244 1 view -0
 730              		.cfi_startproc
 731              		@ args = 0, pretend = 0, frame = 24
 732              		@ frame_needed = 0, uses_anonymous_args = 0
 244:mri/core/cmd_vcont.c ****     char   ch = Buffer_ReadChar(pBuffer);
 733              		.loc 1 244 1 is_stmt 0 view .LVU160
 734 0000 70B5     		push	{r4, r5, r6, lr}
 735              	.LCFI21:
 736              		.cfi_def_cfa_offset 16
 737              		.cfi_offset 4, -16
ARM GAS  /tmp/ccX6djba.s 			page 26


 738              		.cfi_offset 5, -12
 739              		.cfi_offset 6, -8
 740              		.cfi_offset 14, -4
 741 0002 86B0     		sub	sp, sp, #24
 742              	.LCFI22:
 743              		.cfi_def_cfa_offset 40
 744 0004 0546     		mov	r5, r0
 745 0006 0E46     		mov	r6, r1
 245:mri/core/cmd_vcont.c ****     Action action;
 746              		.loc 1 245 5 is_stmt 1 view .LVU161
 245:mri/core/cmd_vcont.c ****     Action action;
 747              		.loc 1 245 17 is_stmt 0 view .LVU162
 748 0008 0846     		mov	r0, r1
 749              	.LVL47:
 245:mri/core/cmd_vcont.c ****     Action action;
 750              		.loc 1 245 17 view .LVU163
 751 000a FFF7FEFF 		bl	mriBuffer_ReadChar
 752              	.LVL48:
 245:mri/core/cmd_vcont.c ****     Action action;
 753              		.loc 1 245 17 view .LVU164
 754 000e 0446     		mov	r4, r0
 755              	.LVL49:
 246:mri/core/cmd_vcont.c ****     mri_memset(&action, 0, sizeof(action));
 756              		.loc 1 246 5 is_stmt 1 view .LVU165
 247:mri/core/cmd_vcont.c ****     switch (ch)
 757              		.loc 1 247 5 view .LVU166
 758 0010 1422     		movs	r2, #20
 759 0012 0021     		movs	r1, #0
 760 0014 01A8     		add	r0, sp, #4
 761 0016 FFF7FEFF 		bl	mri_memset
 762              	.LVL50:
 248:mri/core/cmd_vcont.c ****     {
 763              		.loc 1 248 5 view .LVU167
 764 001a 632C     		cmp	r4, #99
 765 001c 12D0     		beq	.L51
 766 001e 08D9     		bls	.L60
 767 0020 722C     		cmp	r4, #114
 768 0022 1BD0     		beq	.L56
 769 0024 732C     		cmp	r4, #115
 770 0026 1ED1     		bne	.L55
 257:mri/core/cmd_vcont.c ****         case 'S':
 771              		.loc 1 257 13 view .LVU168
 257:mri/core/cmd_vcont.c ****         case 'S':
 772              		.loc 1 257 20 is_stmt 0 view .LVU169
 773 0028 3146     		mov	r1, r6
 774 002a 2846     		mov	r0, r5
 775 002c FFF7FEFF 		bl	parseSingleStepAction
 776              	.LVL51:
 777 0030 0CE0     		b	.L50
 778              	.L60:
 248:mri/core/cmd_vcont.c ****     {
 779              		.loc 1 248 5 view .LVU170
 780 0032 432C     		cmp	r4, #67
 781 0034 0DD0     		beq	.L53
 782 0036 532C     		cmp	r4, #83
 783 0038 15D1     		bne	.L55
 259:mri/core/cmd_vcont.c ****         default:
ARM GAS  /tmp/ccX6djba.s 			page 27


 784              		.loc 1 259 13 is_stmt 1 view .LVU171
 259:mri/core/cmd_vcont.c ****         default:
 785              		.loc 1 259 20 is_stmt 0 view .LVU172
 786 003a 3146     		mov	r1, r6
 787 003c 2846     		mov	r0, r5
 788 003e FFF7FEFF 		bl	parseSingleStepWithSignalAction
 789              	.LVL52:
 790 0042 03E0     		b	.L50
 791              	.L51:
 251:mri/core/cmd_vcont.c ****         case 'C':
 792              		.loc 1 251 13 is_stmt 1 view .LVU173
 251:mri/core/cmd_vcont.c ****         case 'C':
 793              		.loc 1 251 20 is_stmt 0 view .LVU174
 794 0044 3146     		mov	r1, r6
 795 0046 2846     		mov	r0, r5
 796 0048 FFF7FEFF 		bl	parseContinueAction
 797              	.LVL53:
 798              	.L50:
 264:mri/core/cmd_vcont.c **** 
 799              		.loc 1 264 1 view .LVU175
 800 004c 2846     		mov	r0, r5
 801 004e 06B0     		add	sp, sp, #24
 802              	.LCFI23:
 803              		.cfi_remember_state
 804              		.cfi_def_cfa_offset 16
 805              		@ sp needed
 806 0050 70BD     		pop	{r4, r5, r6, pc}
 807              	.LVL54:
 808              	.L53:
 809              	.LCFI24:
 810              		.cfi_restore_state
 253:mri/core/cmd_vcont.c ****         case 'r':
 811              		.loc 1 253 13 is_stmt 1 view .LVU176
 253:mri/core/cmd_vcont.c ****         case 'r':
 812              		.loc 1 253 20 is_stmt 0 view .LVU177
 813 0052 3146     		mov	r1, r6
 814 0054 2846     		mov	r0, r5
 815 0056 FFF7FEFF 		bl	parseContinueWithSignalAction
 816              	.LVL55:
 817 005a F7E7     		b	.L50
 818              	.L56:
 255:mri/core/cmd_vcont.c ****         case 's':
 819              		.loc 1 255 13 is_stmt 1 view .LVU178
 255:mri/core/cmd_vcont.c ****         case 's':
 820              		.loc 1 255 20 is_stmt 0 view .LVU179
 821 005c 3146     		mov	r1, r6
 822 005e 2846     		mov	r0, r5
 823 0060 FFF7FEFF 		bl	parseRangedSingleStepAction
 824              	.LVL56:
 825 0064 F2E7     		b	.L50
 826              	.L55:
 261:mri/core/cmd_vcont.c ****             return action;
 827              		.loc 1 261 13 is_stmt 1 view .LVU180
 828              	.LVL57:
 829              	.LBB34:
 830              	.LBI34:
  71:mri/core/try_catch.h **** {
ARM GAS  /tmp/ccX6djba.s 			page 28


 831              		.loc 2 71 20 view .LVU181
 832              	.LBB35:
  73:mri/core/try_catch.h **** }
 833              		.loc 2 73 5 view .LVU182
  73:mri/core/try_catch.h **** }
 834              		.loc 2 73 73 is_stmt 0 view .LVU183
 835 0066 064A     		ldr	r2, .L61
 836 0068 1368     		ldr	r3, [r2]
 837 006a 042B     		cmp	r3, #4
 838 006c B8BF     		it	lt
 839 006e 0423     		movlt	r3, #4
  73:mri/core/try_catch.h **** }
 840              		.loc 2 73 22 view .LVU184
 841 0070 1360     		str	r3, [r2]
 842              	.LVL58:
  73:mri/core/try_catch.h **** }
 843              		.loc 2 73 22 view .LVU185
 844              	.LBE35:
 845              	.LBE34:
 262:mri/core/cmd_vcont.c ****     }
 846              		.loc 1 262 13 is_stmt 1 view .LVU186
 262:mri/core/cmd_vcont.c ****     }
 847              		.loc 1 262 20 is_stmt 0 view .LVU187
 848 0072 2C46     		mov	r4, r5
 849              	.LVL59:
 262:mri/core/cmd_vcont.c ****     }
 850              		.loc 1 262 20 view .LVU188
 851 0074 01AE     		add	r6, sp, #4
 852              	.LVL60:
 262:mri/core/cmd_vcont.c ****     }
 853              		.loc 1 262 20 view .LVU189
 854 0076 0FCE     		ldmia	r6!, {r0, r1, r2, r3}
 855 0078 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 856 007a 3368     		ldr	r3, [r6]
 857 007c 2360     		str	r3, [r4]
 858 007e E5E7     		b	.L50
 859              	.L62:
 860              		.align	2
 861              	.L61:
 862 0080 00000000 		.word	mriExceptionCode
 863              		.cfi_endproc
 864              	.LFE11:
 866              		.section	.text.isActionSpecificToNonHaltedThreadId,"ax",%progbits
 867              		.align	1
 868              		.syntax unified
 869              		.thumb
 870              		.thumb_func
 872              	isActionSpecificToNonHaltedThreadId:
 873              	.LVL61:
 874              	.LFB9:
 234:mri/core/cmd_vcont.c ****     return pAction->threadId.type == THREAD_ID_SPECIFIC && pAction->threadId.id != Platform_RtosGet
 875              		.loc 1 234 1 is_stmt 1 view -0
 876              		.cfi_startproc
 877              		@ args = 0, pretend = 0, frame = 0
 878              		@ frame_needed = 0, uses_anonymous_args = 0
 235:mri/core/cmd_vcont.c **** }
 879              		.loc 1 235 5 view .LVU191
ARM GAS  /tmp/ccX6djba.s 			page 29


 235:mri/core/cmd_vcont.c **** }
 880              		.loc 1 235 29 is_stmt 0 view .LVU192
 881 0000 90F90430 		ldrsb	r3, [r0, #4]
 235:mri/core/cmd_vcont.c **** }
 882              		.loc 1 235 57 view .LVU193
 883 0004 012B     		cmp	r3, #1
 884 0006 01D0     		beq	.L71
 885 0008 0020     		movs	r0, #0
 886              	.LVL62:
 236:mri/core/cmd_vcont.c **** 
 887              		.loc 1 236 1 view .LVU194
 888 000a 7047     		bx	lr
 889              	.LVL63:
 890              	.L71:
 234:mri/core/cmd_vcont.c ****     return pAction->threadId.type == THREAD_ID_SPECIFIC && pAction->threadId.id != Platform_RtosGet
 891              		.loc 1 234 1 discriminator 1 view .LVU195
 892 000c 10B5     		push	{r4, lr}
 893              	.LCFI25:
 894              		.cfi_def_cfa_offset 8
 895              		.cfi_offset 4, -8
 896              		.cfi_offset 14, -4
 235:mri/core/cmd_vcont.c **** }
 897              		.loc 1 235 77 discriminator 1 view .LVU196
 898 000e 0468     		ldr	r4, [r0]
 235:mri/core/cmd_vcont.c **** }
 899              		.loc 1 235 84 discriminator 1 view .LVU197
 900 0010 FFF7FEFF 		bl	mriPlatform_RtosGetHaltedThreadId
 901              	.LVL64:
 235:mri/core/cmd_vcont.c **** }
 902              		.loc 1 235 57 discriminator 1 view .LVU198
 903 0014 8442     		cmp	r4, r0
 904 0016 01D0     		beq	.L66
 235:mri/core/cmd_vcont.c **** }
 905              		.loc 1 235 57 view .LVU199
 906 0018 0120     		movs	r0, #1
 907              	.L63:
 236:mri/core/cmd_vcont.c **** 
 908              		.loc 1 236 1 view .LVU200
 909 001a 10BD     		pop	{r4, pc}
 910              	.L66:
 235:mri/core/cmd_vcont.c **** }
 911              		.loc 1 235 57 view .LVU201
 912 001c 0020     		movs	r0, #0
 913 001e FCE7     		b	.L63
 914              		.cfi_endproc
 915              	.LFE9:
 917              		.section	.text.isActionSpecificToHaltedThreadId,"ax",%progbits
 918              		.align	1
 919              		.syntax unified
 920              		.thumb
 921              		.thumb_func
 923              	isActionSpecificToHaltedThreadId:
 924              	.LVL65:
 925              	.LFB10:
 239:mri/core/cmd_vcont.c ****     return pAction->threadId.type == THREAD_ID_SPECIFIC && pAction->threadId.id == Platform_RtosGet
 926              		.loc 1 239 1 is_stmt 1 view -0
 927              		.cfi_startproc
ARM GAS  /tmp/ccX6djba.s 			page 30


 928              		@ args = 0, pretend = 0, frame = 0
 929              		@ frame_needed = 0, uses_anonymous_args = 0
 240:mri/core/cmd_vcont.c **** }
 930              		.loc 1 240 5 view .LVU203
 240:mri/core/cmd_vcont.c **** }
 931              		.loc 1 240 29 is_stmt 0 view .LVU204
 932 0000 90F90430 		ldrsb	r3, [r0, #4]
 240:mri/core/cmd_vcont.c **** }
 933              		.loc 1 240 57 view .LVU205
 934 0004 012B     		cmp	r3, #1
 935 0006 01D0     		beq	.L80
 936 0008 0020     		movs	r0, #0
 937              	.LVL66:
 241:mri/core/cmd_vcont.c **** 
 938              		.loc 1 241 1 view .LVU206
 939 000a 7047     		bx	lr
 940              	.LVL67:
 941              	.L80:
 239:mri/core/cmd_vcont.c ****     return pAction->threadId.type == THREAD_ID_SPECIFIC && pAction->threadId.id == Platform_RtosGet
 942              		.loc 1 239 1 discriminator 1 view .LVU207
 943 000c 10B5     		push	{r4, lr}
 944              	.LCFI26:
 945              		.cfi_def_cfa_offset 8
 946              		.cfi_offset 4, -8
 947              		.cfi_offset 14, -4
 240:mri/core/cmd_vcont.c **** }
 948              		.loc 1 240 77 discriminator 1 view .LVU208
 949 000e 0468     		ldr	r4, [r0]
 240:mri/core/cmd_vcont.c **** }
 950              		.loc 1 240 84 discriminator 1 view .LVU209
 951 0010 FFF7FEFF 		bl	mriPlatform_RtosGetHaltedThreadId
 952              	.LVL68:
 240:mri/core/cmd_vcont.c **** }
 953              		.loc 1 240 57 discriminator 1 view .LVU210
 954 0014 8442     		cmp	r4, r0
 955 0016 01D0     		beq	.L81
 240:mri/core/cmd_vcont.c **** }
 956              		.loc 1 240 57 view .LVU211
 957 0018 0020     		movs	r0, #0
 958              	.L72:
 241:mri/core/cmd_vcont.c **** 
 959              		.loc 1 241 1 view .LVU212
 960 001a 10BD     		pop	{r4, pc}
 961              	.L81:
 240:mri/core/cmd_vcont.c **** }
 962              		.loc 1 240 57 view .LVU213
 963 001c 0120     		movs	r0, #1
 964 001e FCE7     		b	.L72
 965              		.cfi_endproc
 966              	.LFE10:
 968              		.section	.text.getActionPriority,"ax",%progbits
 969              		.align	1
 970              		.syntax unified
 971              		.thumb
 972              		.thumb_func
 974              	getActionPriority:
 975              	.LVL69:
ARM GAS  /tmp/ccX6djba.s 			page 31


 976              	.LFB8:
 209:mri/core/cmd_vcont.c ****     /* When Platform_RtosSetThreadState() isn't supported, we will treat actions (ie. single steppi
 977              		.loc 1 209 1 is_stmt 1 view -0
 978              		.cfi_startproc
 979              		@ args = 0, pretend = 0, frame = 0
 980              		@ frame_needed = 0, uses_anonymous_args = 0
 217:mri/core/cmd_vcont.c ****     if (pAction->type == ACTION_NONE)
 981              		.loc 1 217 5 view .LVU215
 218:mri/core/cmd_vcont.c ****         returnValue = 0;
 982              		.loc 1 218 5 view .LVU216
 218:mri/core/cmd_vcont.c ****         returnValue = 0;
 983              		.loc 1 218 16 is_stmt 0 view .LVU217
 984 0000 037C     		ldrb	r3, [r0, #16]	@ zero_extendqisi2
 218:mri/core/cmd_vcont.c ****         returnValue = 0;
 985              		.loc 1 218 8 view .LVU218
 986 0002 0BB9     		cbnz	r3, .L96
 219:mri/core/cmd_vcont.c ****     else if (Platform_RtosIsSetThreadStateSupported() && isActionSpecificToNonHaltedThreadId(pActio
 987              		.loc 1 219 21 view .LVU219
 988 0004 0020     		movs	r0, #0
 989              	.LVL70:
 231:mri/core/cmd_vcont.c **** 
 990              		.loc 1 231 1 view .LVU220
 991 0006 7047     		bx	lr
 992              	.LVL71:
 993              	.L96:
 209:mri/core/cmd_vcont.c ****     /* When Platform_RtosSetThreadState() isn't supported, we will treat actions (ie. single steppi
 994              		.loc 1 209 1 view .LVU221
 995 0008 10B5     		push	{r4, lr}
 996              	.LCFI27:
 997              		.cfi_def_cfa_offset 8
 998              		.cfi_offset 4, -8
 999              		.cfi_offset 14, -4
 1000 000a 0446     		mov	r4, r0
 220:mri/core/cmd_vcont.c ****         returnValue = 0;
 1001              		.loc 1 220 10 is_stmt 1 view .LVU222
 220:mri/core/cmd_vcont.c ****         returnValue = 0;
 1002              		.loc 1 220 14 is_stmt 0 view .LVU223
 1003 000c FFF7FEFF 		bl	mriPlatform_RtosIsSetThreadStateSupported
 1004              	.LVL72:
 220:mri/core/cmd_vcont.c ****         returnValue = 0;
 1005              		.loc 1 220 13 view .LVU224
 1006 0010 20B9     		cbnz	r0, .L97
 1007              	.L84:
 222:mri/core/cmd_vcont.c ****         returnValue = 1;
 1008              		.loc 1 222 10 is_stmt 1 view .LVU225
 222:mri/core/cmd_vcont.c ****         returnValue = 1;
 1009              		.loc 1 222 31 is_stmt 0 view .LVU226
 1010 0012 94F90430 		ldrsb	r3, [r4, #4]
 222:mri/core/cmd_vcont.c ****         returnValue = 1;
 1011              		.loc 1 222 13 view .LVU227
 1012 0016 43B9     		cbnz	r3, .L98
 223:mri/core/cmd_vcont.c ****     else if (!Platform_RtosIsSetThreadStateSupported() && isActionSpecificToNonHaltedThreadId(pActi
 1013              		.loc 1 223 21 view .LVU228
 1014 0018 0120     		movs	r0, #1
 1015              	.LVL73:
 1016              	.L82:
 231:mri/core/cmd_vcont.c **** 
ARM GAS  /tmp/ccX6djba.s 			page 32


 1017              		.loc 1 231 1 view .LVU229
 1018 001a 10BD     		pop	{r4, pc}
 1019              	.LVL74:
 1020              	.L97:
 220:mri/core/cmd_vcont.c ****         returnValue = 0;
 1021              		.loc 1 220 58 discriminator 1 view .LVU230
 1022 001c 2046     		mov	r0, r4
 1023 001e FFF7FEFF 		bl	isActionSpecificToNonHaltedThreadId
 1024              	.LVL75:
 220:mri/core/cmd_vcont.c ****         returnValue = 0;
 1025              		.loc 1 220 55 discriminator 1 view .LVU231
 1026 0022 0028     		cmp	r0, #0
 1027 0024 F5D0     		beq	.L84
 221:mri/core/cmd_vcont.c ****     else if (pAction->threadId.type == THREAD_ID_NONE)
 1028              		.loc 1 221 21 view .LVU232
 1029 0026 0020     		movs	r0, #0
 1030 0028 F7E7     		b	.L82
 1031              	.L98:
 224:mri/core/cmd_vcont.c ****         returnValue = 2;
 1032              		.loc 1 224 10 is_stmt 1 view .LVU233
 224:mri/core/cmd_vcont.c ****         returnValue = 2;
 1033              		.loc 1 224 15 is_stmt 0 view .LVU234
 1034 002a FFF7FEFF 		bl	mriPlatform_RtosIsSetThreadStateSupported
 1035              	.LVL76:
 224:mri/core/cmd_vcont.c ****         returnValue = 2;
 1036              		.loc 1 224 13 view .LVU235
 1037 002e 58B1     		cbz	r0, .L99
 1038              	.L85:
 226:mri/core/cmd_vcont.c ****         returnValue = 3;
 1039              		.loc 1 226 10 is_stmt 1 view .LVU236
 226:mri/core/cmd_vcont.c ****         returnValue = 3;
 1040              		.loc 1 226 31 is_stmt 0 view .LVU237
 1041 0030 94F90430 		ldrsb	r3, [r4, #4]
 226:mri/core/cmd_vcont.c ****         returnValue = 3;
 1042              		.loc 1 226 13 view .LVU238
 1043 0034 B3F1FF3F 		cmp	r3, #-1
 1044 0038 0DD0     		beq	.L90
 228:mri/core/cmd_vcont.c ****         returnValue = 4;
 1045              		.loc 1 228 10 is_stmt 1 view .LVU239
 228:mri/core/cmd_vcont.c ****         returnValue = 4;
 1046              		.loc 1 228 14 is_stmt 0 view .LVU240
 1047 003a 2046     		mov	r0, r4
 1048 003c FFF7FEFF 		bl	isActionSpecificToHaltedThreadId
 1049              	.LVL77:
 228:mri/core/cmd_vcont.c ****         returnValue = 4;
 1050              		.loc 1 228 13 view .LVU241
 1051 0040 0028     		cmp	r0, #0
 1052 0042 EAD0     		beq	.L82
 229:mri/core/cmd_vcont.c ****     return returnValue;
 1053              		.loc 1 229 21 view .LVU242
 1054 0044 0420     		movs	r0, #4
 1055              	.LVL78:
 230:mri/core/cmd_vcont.c **** }
 1056              		.loc 1 230 5 is_stmt 1 view .LVU243
 230:mri/core/cmd_vcont.c **** }
 1057              		.loc 1 230 12 is_stmt 0 view .LVU244
 1058 0046 E8E7     		b	.L82
ARM GAS  /tmp/ccX6djba.s 			page 33


 1059              	.LVL79:
 1060              	.L99:
 224:mri/core/cmd_vcont.c ****         returnValue = 2;
 1061              		.loc 1 224 59 discriminator 1 view .LVU245
 1062 0048 2046     		mov	r0, r4
 1063 004a FFF7FEFF 		bl	isActionSpecificToNonHaltedThreadId
 1064              	.LVL80:
 224:mri/core/cmd_vcont.c ****         returnValue = 2;
 1065              		.loc 1 224 56 discriminator 1 view .LVU246
 1066 004e 0028     		cmp	r0, #0
 1067 0050 EED0     		beq	.L85
 225:mri/core/cmd_vcont.c ****     else if (pAction->threadId.type == THREAD_ID_ALL)
 1068              		.loc 1 225 21 view .LVU247
 1069 0052 0220     		movs	r0, #2
 1070 0054 E1E7     		b	.L82
 1071              	.L90:
 227:mri/core/cmd_vcont.c ****     else if (isActionSpecificToHaltedThreadId(pAction))
 1072              		.loc 1 227 21 view .LVU248
 1073 0056 0320     		movs	r0, #3
 1074 0058 DFE7     		b	.L82
 1075              		.cfi_endproc
 1076              	.LFE8:
 1078              		.section	.text.isActionMoreSpecificThanCurrent,"ax",%progbits
 1079              		.align	1
 1080              		.syntax unified
 1081              		.thumb
 1082              		.thumb_func
 1084              	isActionMoreSpecificThanCurrent:
 1085              	.LVL81:
 1086              	.LFB7:
 202:mri/core/cmd_vcont.c ****     uint32_t currPriority = getActionPriority(pCurr);
 1087              		.loc 1 202 1 is_stmt 1 view -0
 1088              		.cfi_startproc
 1089              		@ args = 0, pretend = 0, frame = 0
 1090              		@ frame_needed = 0, uses_anonymous_args = 0
 202:mri/core/cmd_vcont.c ****     uint32_t currPriority = getActionPriority(pCurr);
 1091              		.loc 1 202 1 is_stmt 0 view .LVU250
 1092 0000 38B5     		push	{r3, r4, r5, lr}
 1093              	.LCFI28:
 1094              		.cfi_def_cfa_offset 16
 1095              		.cfi_offset 3, -16
 1096              		.cfi_offset 4, -12
 1097              		.cfi_offset 5, -8
 1098              		.cfi_offset 14, -4
 1099 0002 0D46     		mov	r5, r1
 203:mri/core/cmd_vcont.c ****     uint32_t newPriority = getActionPriority(pNew);
 1100              		.loc 1 203 5 is_stmt 1 view .LVU251
 203:mri/core/cmd_vcont.c ****     uint32_t newPriority = getActionPriority(pNew);
 1101              		.loc 1 203 29 is_stmt 0 view .LVU252
 1102 0004 FFF7FEFF 		bl	getActionPriority
 1103              	.LVL82:
 203:mri/core/cmd_vcont.c ****     uint32_t newPriority = getActionPriority(pNew);
 1104              		.loc 1 203 29 view .LVU253
 1105 0008 0446     		mov	r4, r0
 1106              	.LVL83:
 204:mri/core/cmd_vcont.c ****     return newPriority > currPriority;
 1107              		.loc 1 204 5 is_stmt 1 view .LVU254
ARM GAS  /tmp/ccX6djba.s 			page 34


 204:mri/core/cmd_vcont.c ****     return newPriority > currPriority;
 1108              		.loc 1 204 28 is_stmt 0 view .LVU255
 1109 000a 2846     		mov	r0, r5
 1110              	.LVL84:
 204:mri/core/cmd_vcont.c ****     return newPriority > currPriority;
 1111              		.loc 1 204 28 view .LVU256
 1112 000c FFF7FEFF 		bl	getActionPriority
 1113              	.LVL85:
 205:mri/core/cmd_vcont.c **** }
 1114              		.loc 1 205 5 is_stmt 1 view .LVU257
 206:mri/core/cmd_vcont.c **** 
 1115              		.loc 1 206 1 is_stmt 0 view .LVU258
 1116 0010 8442     		cmp	r4, r0
 1117 0012 2CBF     		ite	cs
 1118 0014 0020     		movcs	r0, #0
 1119              	.LVL86:
 206:mri/core/cmd_vcont.c **** 
 1120              		.loc 1 206 1 view .LVU259
 1121 0016 0120     		movcc	r0, #1
 1122 0018 38BD     		pop	{r3, r4, r5, pc}
 206:mri/core/cmd_vcont.c **** 
 1123              		.loc 1 206 1 view .LVU260
 1124              		.cfi_endproc
 1125              	.LFE7:
 1127              		.section	.rodata.firstParsePass.str1.4,"aMS",%progbits,1
 1128              		.align	2
 1129              	.LC1:
 1130 0000 45303100 		.ascii	"E01\000"
 1131              		.section	.text.firstParsePass,"ax",%progbits
 1132              		.align	1
 1133              		.syntax unified
 1134              		.thumb
 1135              		.thumb_func
 1137              	firstParsePass:
 1138              	.LVL87:
 1139              	.LFB6:
 151:mri/core/cmd_vcont.c ****     uint32_t actionCount = 0;
 1140              		.loc 1 151 1 is_stmt 1 view -0
 1141              		.cfi_startproc
 1142              		@ args = 0, pretend = 0, frame = 48
 1143              		@ frame_needed = 0, uses_anonymous_args = 0
 151:mri/core/cmd_vcont.c ****     uint32_t actionCount = 0;
 1144              		.loc 1 151 1 is_stmt 0 view .LVU262
 1145 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1146              	.LCFI29:
 1147              		.cfi_def_cfa_offset 24
 1148              		.cfi_offset 4, -24
 1149              		.cfi_offset 5, -20
 1150              		.cfi_offset 6, -16
 1151              		.cfi_offset 7, -12
 1152              		.cfi_offset 8, -8
 1153              		.cfi_offset 14, -4
 1154 0004 8CB0     		sub	sp, sp, #48
 1155              	.LCFI30:
 1156              		.cfi_def_cfa_offset 72
 1157 0006 0446     		mov	r4, r0
 1158 0008 0E46     		mov	r6, r1
ARM GAS  /tmp/ccX6djba.s 			page 35


 1159 000a 1746     		mov	r7, r2
 152:mri/core/cmd_vcont.c ****     Action   action;
 1160              		.loc 1 152 5 is_stmt 1 view .LVU263
 1161              	.LVL88:
 153:mri/core/cmd_vcont.c **** 
 1162              		.loc 1 153 5 view .LVU264
 155:mri/core/cmd_vcont.c ****     {
 1163              		.loc 1 155 5 view .LVU265
 152:mri/core/cmd_vcont.c ****     Action   action;
 1164              		.loc 1 152 14 is_stmt 0 view .LVU266
 1165 000c 0025     		movs	r5, #0
 155:mri/core/cmd_vcont.c ****     {
 1166              		.loc 1 155 11 view .LVU267
 1167 000e 15E0     		b	.L103
 1168              	.LVL89:
 1169              	.L115:
 163:mri/core/cmd_vcont.c ****             __rethrow;
 1170              		.loc 1 163 13 is_stmt 1 view .LVU268
 1171 0010 4248     		ldr	r0, .L118
 1172 0012 FFF7FEFF 		bl	mriCore_PrepareStringResponse
 1173              	.LVL90:
 164:mri/core/cmd_vcont.c ****         }
 1174              		.loc 1 164 13 view .LVU269
 1175              	.L102:
 199:mri/core/cmd_vcont.c **** 
 1176              		.loc 1 199 1 is_stmt 0 view .LVU270
 1177 0016 0CB0     		add	sp, sp, #48
 1178              	.LCFI31:
 1179              		.cfi_remember_state
 1180              		.cfi_def_cfa_offset 24
 1181              		@ sp needed
 1182 0018 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1183              	.LVL91:
 1184              	.L106:
 1185              	.LCFI32:
 1186              		.cfi_restore_state
 176:mri/core/cmd_vcont.c ****                     *pContinueAction = action;
 1187              		.loc 1 176 17 is_stmt 1 view .LVU271
 176:mri/core/cmd_vcont.c ****                     *pContinueAction = action;
 1188              		.loc 1 176 21 is_stmt 0 view .LVU272
 1189 001c 07A9     		add	r1, sp, #28
 1190 001e 3046     		mov	r0, r6
 1191 0020 FFF7FEFF 		bl	isActionMoreSpecificThanCurrent
 1192              	.LVL92:
 176:mri/core/cmd_vcont.c ****                     *pContinueAction = action;
 1193              		.loc 1 176 20 view .LVU273
 1194 0024 50B1     		cbz	r0, .L103
 177:mri/core/cmd_vcont.c ****                 break;
 1195              		.loc 1 177 21 is_stmt 1 view .LVU274
 177:mri/core/cmd_vcont.c ****                 break;
 1196              		.loc 1 177 38 is_stmt 0 view .LVU275
 1197 0026 B446     		mov	ip, r6
 1198 0028 0DF11C0E 		add	lr, sp, #28
 1199 002c BEE80F00 		ldmia	lr!, {r0, r1, r2, r3}
 1200 0030 ACE80F00 		stmia	ip!, {r0, r1, r2, r3}
 1201 0034 DEF80030 		ldr	r3, [lr]
 1202 0038 CCF80030 		str	r3, [ip]
ARM GAS  /tmp/ccX6djba.s 			page 36


 1203              	.LVL93:
 1204              	.L103:
 155:mri/core/cmd_vcont.c ****     {
 1205              		.loc 1 155 42 is_stmt 1 view .LVU276
 155:mri/core/cmd_vcont.c ****     {
 1206              		.loc 1 155 12 is_stmt 0 view .LVU277
 1207 003c 2046     		mov	r0, r4
 1208 003e FFF7FEFF 		bl	mriBuffer_BytesLeft
 1209              	.LVL94:
 155:mri/core/cmd_vcont.c ****     {
 1210              		.loc 1 155 42 view .LVU278
 1211 0042 0028     		cmp	r0, #0
 1212 0044 3AD0     		beq	.L108
 155:mri/core/cmd_vcont.c ****     {
 1213              		.loc 1 155 45 discriminator 1 view .LVU279
 1214 0046 3B21     		movs	r1, #59
 1215 0048 2046     		mov	r0, r4
 1216 004a FFF7FEFF 		bl	mriBuffer_IsNextCharEqualTo
 1217              	.LVL95:
 155:mri/core/cmd_vcont.c ****     {
 1218              		.loc 1 155 42 discriminator 1 view .LVU280
 1219 004e A8B3     		cbz	r0, .L108
 157:mri/core/cmd_vcont.c ****         {
 1220              		.loc 1 157 9 is_stmt 1 view .LVU281
 157:mri/core/cmd_vcont.c ****         {
 1221              		.loc 1 157 9 view .LVU282
 1222              	.LBB36:
 1223              	.LBI36:
  76:mri/core/try_catch.h **** {
 1224              		.loc 2 76 20 view .LVU283
 1225              	.LBB37:
 1226              		.loc 2 78 5 view .LVU284
 1227              		.loc 2 78 22 is_stmt 0 view .LVU285
 1228 0050 DFF8CC80 		ldr	r8, .L118+4
 1229 0054 0023     		movs	r3, #0
 1230 0056 C8F80030 		str	r3, [r8]
 1231              	.LBE37:
 1232              	.LBE36:
 159:mri/core/cmd_vcont.c ****         }
 1233              		.loc 1 159 13 is_stmt 1 view .LVU286
 159:mri/core/cmd_vcont.c ****         }
 1234              		.loc 1 159 22 is_stmt 0 view .LVU287
 1235 005a 2146     		mov	r1, r4
 1236 005c 6846     		mov	r0, sp
 1237 005e FFF7FEFF 		bl	parseAction
 1238              	.LVL96:
 1239 0062 0DF11C0E 		add	lr, sp, #28
 1240 0066 EC46     		mov	ip, sp
 1241 0068 BCE80F00 		ldmia	ip!, {r0, r1, r2, r3}
 1242 006c AEE80F00 		stmia	lr!, {r0, r1, r2, r3}
 1243 0070 DCF80030 		ldr	r3, [ip]
 1244 0074 CEF80030 		str	r3, [lr]
 157:mri/core/cmd_vcont.c ****         {
 1245              		.loc 1 157 9 is_stmt 1 view .LVU288
 161:mri/core/cmd_vcont.c ****         {
 1246              		.loc 1 161 9 view .LVU289
 1247 0078 D8F80030 		ldr	r3, [r8]
ARM GAS  /tmp/ccX6djba.s 			page 37


 1248 007c 002B     		cmp	r3, #0
 1249 007e C7D1     		bne	.L115
 167:mri/core/cmd_vcont.c ****         switch (action.type)
 1250              		.loc 1 167 9 view .LVU290
 167:mri/core/cmd_vcont.c ****         switch (action.type)
 1251              		.loc 1 167 20 is_stmt 0 view .LVU291
 1252 0080 0135     		adds	r5, r5, #1
 1253              	.LVL97:
 168:mri/core/cmd_vcont.c ****         {
 1254              		.loc 1 168 9 is_stmt 1 view .LVU292
 168:mri/core/cmd_vcont.c ****         {
 1255              		.loc 1 168 23 is_stmt 0 view .LVU293
 1256 0082 9DF82C30 		ldrb	r3, [sp, #44]	@ zero_extendqisi2
 168:mri/core/cmd_vcont.c ****         {
 1257              		.loc 1 168 9 view .LVU294
 1258 0086 012B     		cmp	r3, #1
 1259 0088 C8D0     		beq	.L106
 1260 008a 5AB2     		sxtb	r2, r3
 1261 008c 002A     		cmp	r2, #0
 1262 008e D5D0     		beq	.L103
 1263 0090 023B     		subs	r3, r3, #2
 1264 0092 DBB2     		uxtb	r3, r3
 1265 0094 012B     		cmp	r3, #1
 1266 0096 D1D8     		bhi	.L103
 172:mri/core/cmd_vcont.c ****                     *pStepAction = action;
 1267              		.loc 1 172 17 is_stmt 1 view .LVU295
 172:mri/core/cmd_vcont.c ****                     *pStepAction = action;
 1268              		.loc 1 172 21 is_stmt 0 view .LVU296
 1269 0098 07A9     		add	r1, sp, #28
 1270 009a 3846     		mov	r0, r7
 1271 009c FFF7FEFF 		bl	isActionMoreSpecificThanCurrent
 1272              	.LVL98:
 172:mri/core/cmd_vcont.c ****                     *pStepAction = action;
 1273              		.loc 1 172 20 view .LVU297
 1274 00a0 0028     		cmp	r0, #0
 1275 00a2 CBD0     		beq	.L103
 173:mri/core/cmd_vcont.c ****                 break;
 1276              		.loc 1 173 21 is_stmt 1 view .LVU298
 173:mri/core/cmd_vcont.c ****                 break;
 1277              		.loc 1 173 34 is_stmt 0 view .LVU299
 1278 00a4 BC46     		mov	ip, r7
 1279 00a6 0DF11C0E 		add	lr, sp, #28
 1280 00aa BEE80F00 		ldmia	lr!, {r0, r1, r2, r3}
 1281 00ae ACE80F00 		stmia	ip!, {r0, r1, r2, r3}
 1282 00b2 DEF80030 		ldr	r3, [lr]
 1283 00b6 CCF80030 		str	r3, [ip]
 1284 00ba BFE7     		b	.L103
 1285              	.L108:
 183:mri/core/cmd_vcont.c ****     {
 1286              		.loc 1 183 5 is_stmt 1 view .LVU300
 183:mri/core/cmd_vcont.c ****     {
 1287              		.loc 1 183 9 is_stmt 0 view .LVU301
 1288 00bc 2046     		mov	r0, r4
 1289 00be FFF7FEFF 		bl	mriBuffer_BytesLeft
 1290              	.LVL99:
 183:mri/core/cmd_vcont.c ****     {
 1291              		.loc 1 183 8 view .LVU302
ARM GAS  /tmp/ccX6djba.s 			page 38


 1292 00c2 B0B9     		cbnz	r0, .L116
 189:mri/core/cmd_vcont.c ****     {
 1293              		.loc 1 189 5 is_stmt 1 view .LVU303
 189:mri/core/cmd_vcont.c ****     {
 1294              		.loc 1 189 10 is_stmt 0 view .LVU304
 1295 00c4 FFF7FEFF 		bl	mriPlatform_RtosIsSetThreadStateSupported
 1296              	.LVL100:
 189:mri/core/cmd_vcont.c ****     {
 1297              		.loc 1 189 8 view .LVU305
 1298 00c8 18B9     		cbnz	r0, .L111
 189:mri/core/cmd_vcont.c ****     {
 1299              		.loc 1 189 69 discriminator 1 view .LVU306
 1300 00ca 337C     		ldrb	r3, [r6, #16]	@ zero_extendqisi2
 189:mri/core/cmd_vcont.c ****     {
 1301              		.loc 1 189 51 discriminator 1 view .LVU307
 1302 00cc 0BB9     		cbnz	r3, .L111
 189:mri/core/cmd_vcont.c ****     {
 1303              		.loc 1 189 105 discriminator 2 view .LVU308
 1304 00ce 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 189:mri/core/cmd_vcont.c ****     {
 1305              		.loc 1 189 91 discriminator 2 view .LVU309
 1306 00d0 CBB1     		cbz	r3, .L117
 1307              	.L111:
 194:mri/core/cmd_vcont.c ****     {
 1308              		.loc 1 194 5 is_stmt 1 view .LVU310
 194:mri/core/cmd_vcont.c ****     {
 1309              		.loc 1 194 9 is_stmt 0 view .LVU311
 1310 00d2 FFF7FEFF 		bl	mriPlatform_RtosIsSetThreadStateSupported
 1311              	.LVL101:
 194:mri/core/cmd_vcont.c ****     {
 1312              		.loc 1 194 8 view .LVU312
 1313 00d6 0028     		cmp	r0, #0
 1314 00d8 9DD0     		beq	.L102
 194:mri/core/cmd_vcont.c ****     {
 1315              		.loc 1 194 50 discriminator 1 view .LVU313
 1316 00da 002D     		cmp	r5, #0
 1317 00dc 9BD1     		bne	.L102
 196:mri/core/cmd_vcont.c ****         __throw(invalidArgumentException);
 1318              		.loc 1 196 9 is_stmt 1 view .LVU314
 1319 00de 0F48     		ldr	r0, .L118
 1320 00e0 FFF7FEFF 		bl	mriCore_PrepareStringResponse
 1321              	.LVL102:
 197:mri/core/cmd_vcont.c ****     }
 1322              		.loc 1 197 9 view .LVU315
 1323              	.LBB38:
 1324              	.LBI38:
  71:mri/core/try_catch.h **** {
 1325              		.loc 2 71 20 view .LVU316
 1326              	.LBB39:
  73:mri/core/try_catch.h **** }
 1327              		.loc 2 73 5 view .LVU317
  73:mri/core/try_catch.h **** }
 1328              		.loc 2 73 73 is_stmt 0 view .LVU318
 1329 00e4 0E4A     		ldr	r2, .L118+4
 1330 00e6 1368     		ldr	r3, [r2]
 1331 00e8 042B     		cmp	r3, #4
 1332 00ea B8BF     		it	lt
ARM GAS  /tmp/ccX6djba.s 			page 39


 1333 00ec 0423     		movlt	r3, #4
  73:mri/core/try_catch.h **** }
 1334              		.loc 2 73 22 view .LVU319
 1335 00ee 1360     		str	r3, [r2]
 1336              	.LVL103:
  73:mri/core/try_catch.h **** }
 1337              		.loc 2 73 22 view .LVU320
 1338              	.LBE39:
 1339              	.LBE38:
 197:mri/core/cmd_vcont.c ****     }
 1340              		.loc 1 197 9 view .LVU321
 1341 00f0 91E7     		b	.L102
 1342              	.L116:
 186:mri/core/cmd_vcont.c ****         __throw(invalidArgumentException);
 1343              		.loc 1 186 9 is_stmt 1 view .LVU322
 1344 00f2 0A48     		ldr	r0, .L118
 1345 00f4 FFF7FEFF 		bl	mriCore_PrepareStringResponse
 1346              	.LVL104:
 187:mri/core/cmd_vcont.c ****     }
 1347              		.loc 1 187 9 view .LVU323
 1348              	.LBB40:
 1349              	.LBI40:
  71:mri/core/try_catch.h **** {
 1350              		.loc 2 71 20 view .LVU324
 1351              	.LBB41:
  73:mri/core/try_catch.h **** }
 1352              		.loc 2 73 5 view .LVU325
  73:mri/core/try_catch.h **** }
 1353              		.loc 2 73 73 is_stmt 0 view .LVU326
 1354 00f8 094A     		ldr	r2, .L118+4
 1355 00fa 1368     		ldr	r3, [r2]
 1356 00fc 042B     		cmp	r3, #4
 1357 00fe B8BF     		it	lt
 1358 0100 0423     		movlt	r3, #4
  73:mri/core/try_catch.h **** }
 1359              		.loc 2 73 22 view .LVU327
 1360 0102 1360     		str	r3, [r2]
 1361              	.LVL105:
  73:mri/core/try_catch.h **** }
 1362              		.loc 2 73 22 view .LVU328
 1363              	.LBE41:
 1364              	.LBE40:
 187:mri/core/cmd_vcont.c ****     }
 1365              		.loc 1 187 9 view .LVU329
 1366 0104 87E7     		b	.L102
 1367              	.L117:
 191:mri/core/cmd_vcont.c ****         __throw(invalidArgumentException);
 1368              		.loc 1 191 9 is_stmt 1 view .LVU330
 1369 0106 0548     		ldr	r0, .L118
 1370 0108 FFF7FEFF 		bl	mriCore_PrepareStringResponse
 1371              	.LVL106:
 192:mri/core/cmd_vcont.c ****     }
 1372              		.loc 1 192 9 view .LVU331
 1373              	.LBB42:
 1374              	.LBI42:
  71:mri/core/try_catch.h **** {
 1375              		.loc 2 71 20 view .LVU332
ARM GAS  /tmp/ccX6djba.s 			page 40


 1376              	.LBB43:
  73:mri/core/try_catch.h **** }
 1377              		.loc 2 73 5 view .LVU333
  73:mri/core/try_catch.h **** }
 1378              		.loc 2 73 73 is_stmt 0 view .LVU334
 1379 010c 044A     		ldr	r2, .L118+4
 1380 010e 1368     		ldr	r3, [r2]
 1381 0110 042B     		cmp	r3, #4
 1382 0112 B8BF     		it	lt
 1383 0114 0423     		movlt	r3, #4
  73:mri/core/try_catch.h **** }
 1384              		.loc 2 73 22 view .LVU335
 1385 0116 1360     		str	r3, [r2]
 1386              	.LVL107:
  73:mri/core/try_catch.h **** }
 1387              		.loc 2 73 22 view .LVU336
 1388              	.LBE43:
 1389              	.LBE42:
 192:mri/core/cmd_vcont.c ****     }
 1390              		.loc 1 192 9 view .LVU337
 1391 0118 7DE7     		b	.L102
 1392              	.L119:
 1393 011a 00BF     		.align	2
 1394              	.L118:
 1395 011c 00000000 		.word	.LC1
 1396 0120 00000000 		.word	mriExceptionCode
 1397              		.cfi_endproc
 1398              	.LFE6:
 1400              		.section	.text.handleActionWithSetThreadState,"ax",%progbits
 1401              		.align	1
 1402              		.syntax unified
 1403              		.thumb
 1404              		.thumb_func
 1406              	handleActionWithSetThreadState:
 1407              	.LVL108:
 1408              	.LFB24:
 446:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 1409              		.loc 1 446 1 is_stmt 1 view -0
 1410              		.cfi_startproc
 1411              		@ args = 0, pretend = 0, frame = 0
 1412              		@ frame_needed = 0, uses_anonymous_args = 0
 446:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 1413              		.loc 1 446 1 is_stmt 0 view .LVU339
 1414 0000 10B5     		push	{r4, lr}
 1415              	.LCFI33:
 1416              		.cfi_def_cfa_offset 8
 1417              		.cfi_offset 4, -8
 1418              		.cfi_offset 14, -4
 1419 0002 0446     		mov	r4, r0
 447:mri/core/cmd_vcont.c ****     uint32_t threadId = getThreadIdFromAction(pAction);
 1420              		.loc 1 447 5 is_stmt 1 view .LVU340
 1421              	.LVL109:
 448:mri/core/cmd_vcont.c **** 
 1422              		.loc 1 448 5 view .LVU341
 448:mri/core/cmd_vcont.c **** 
 1423              		.loc 1 448 25 is_stmt 0 view .LVU342
 1424 0004 FFF7FEFF 		bl	getThreadIdFromAction
ARM GAS  /tmp/ccX6djba.s 			page 41


 1425              	.LVL110:
 450:mri/core/cmd_vcont.c ****     {
 1426              		.loc 1 450 5 is_stmt 1 view .LVU343
 450:mri/core/cmd_vcont.c ****     {
 1427              		.loc 1 450 20 is_stmt 0 view .LVU344
 1428 0008 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 450:mri/core/cmd_vcont.c ****     {
 1429              		.loc 1 450 5 view .LVU345
 1430 000a 022B     		cmp	r3, #2
 1431 000c 0AD0     		beq	.L121
 1432 000e 032B     		cmp	r3, #3
 1433 0010 0FD0     		beq	.L122
 1434 0012 012B     		cmp	r3, #1
 1435 0014 01D0     		beq	.L126
 1436 0016 0020     		movs	r0, #0
 1437              	.LVL111:
 470:mri/core/cmd_vcont.c **** }
 1438              		.loc 1 470 4 is_stmt 1 view .LVU346
 1439              	.L120:
 471:mri/core/cmd_vcont.c **** 
 1440              		.loc 1 471 1 is_stmt 0 view .LVU347
 1441 0018 10BD     		pop	{r4, pc}
 1442              	.LVL112:
 1443              	.L126:
 453:mri/core/cmd_vcont.c ****             returnValue = HANDLER_RETURN_RESUME_PROGRAM | HANDLER_RETURN_RETURN_IMMEDIATELY;
 1444              		.loc 1 453 13 is_stmt 1 view .LVU348
 1445 001a 0121     		movs	r1, #1
 1446 001c FFF7FEFF 		bl	mriPlatform_RtosSetThreadState
 1447              	.LVL113:
 454:mri/core/cmd_vcont.c ****             break;
 1448              		.loc 1 454 13 view .LVU349
 455:mri/core/cmd_vcont.c ****         case ACTION_SINGLE_STEP:
 1449              		.loc 1 455 13 view .LVU350
 454:mri/core/cmd_vcont.c ****             break;
 1450              		.loc 1 454 25 is_stmt 0 view .LVU351
 1451 0020 0320     		movs	r0, #3
 455:mri/core/cmd_vcont.c ****         case ACTION_SINGLE_STEP:
 1452              		.loc 1 455 13 view .LVU352
 1453 0022 F9E7     		b	.L120
 1454              	.LVL114:
 1455              	.L121:
 457:mri/core/cmd_vcont.c ****             Platform_EnableSingleStep();
 1456              		.loc 1 457 13 is_stmt 1 view .LVU353
 1457 0024 0221     		movs	r1, #2
 1458 0026 FFF7FEFF 		bl	mriPlatform_RtosSetThreadState
 1459              	.LVL115:
 458:mri/core/cmd_vcont.c ****             returnValue = HANDLER_RETURN_RESUME_PROGRAM | HANDLER_RETURN_RETURN_IMMEDIATELY;
 1460              		.loc 1 458 13 view .LVU354
 1461 002a FFF7FEFF 		bl	mriPlatform_EnableSingleStep
 1462              	.LVL116:
 459:mri/core/cmd_vcont.c ****             break;
 1463              		.loc 1 459 13 view .LVU355
 460:mri/core/cmd_vcont.c ****         case ACTION_RANGED_SINGLE_STEP:
 1464              		.loc 1 460 13 view .LVU356
 459:mri/core/cmd_vcont.c ****             break;
 1465              		.loc 1 459 25 is_stmt 0 view .LVU357
 1466 002e 0320     		movs	r0, #3
ARM GAS  /tmp/ccX6djba.s 			page 42


 460:mri/core/cmd_vcont.c ****         case ACTION_RANGED_SINGLE_STEP:
 1467              		.loc 1 460 13 view .LVU358
 1468 0030 F2E7     		b	.L120
 1469              	.LVL117:
 1470              	.L122:
 462:mri/core/cmd_vcont.c ****             Platform_EnableSingleStep();
 1471              		.loc 1 462 13 is_stmt 1 view .LVU359
 1472 0032 0221     		movs	r1, #2
 1473 0034 FFF7FEFF 		bl	mriPlatform_RtosSetThreadState
 1474              	.LVL118:
 463:mri/core/cmd_vcont.c ****             SetSingleSteppingRange(&pAction->range);
 1475              		.loc 1 463 13 view .LVU360
 1476 0038 FFF7FEFF 		bl	mriPlatform_EnableSingleStep
 1477              	.LVL119:
 464:mri/core/cmd_vcont.c ****             returnValue = HANDLER_RETURN_RESUME_PROGRAM | HANDLER_RETURN_RETURN_IMMEDIATELY;
 1478              		.loc 1 464 13 view .LVU361
 1479 003c 04F10800 		add	r0, r4, #8
 1480 0040 FFF7FEFF 		bl	mriCore_SetSingleSteppingRange
 1481              	.LVL120:
 465:mri/core/cmd_vcont.c ****             break;
 1482              		.loc 1 465 13 view .LVU362
 466:mri/core/cmd_vcont.c ****         default:
 1483              		.loc 1 466 13 view .LVU363
 465:mri/core/cmd_vcont.c ****             break;
 1484              		.loc 1 465 25 is_stmt 0 view .LVU364
 1485 0044 0320     		movs	r0, #3
 466:mri/core/cmd_vcont.c ****         default:
 1486              		.loc 1 466 13 view .LVU365
 1487 0046 E7E7     		b	.L120
 1488              		.cfi_endproc
 1489              	.LFE24:
 1491              		.section	.text.secondParsePass,"ax",%progbits
 1492              		.align	1
 1493              		.syntax unified
 1494              		.thumb
 1495              		.thumb_func
 1497              	secondParsePass:
 1498              	.LVL121:
 1499              	.LFB23:
 433:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 1500              		.loc 1 433 1 is_stmt 1 view -0
 1501              		.cfi_startproc
 1502              		@ args = 0, pretend = 0, frame = 48
 1503              		@ frame_needed = 0, uses_anonymous_args = 0
 433:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 1504              		.loc 1 433 1 is_stmt 0 view .LVU367
 1505 0000 30B5     		push	{r4, r5, lr}
 1506              	.LCFI34:
 1507              		.cfi_def_cfa_offset 12
 1508              		.cfi_offset 4, -12
 1509              		.cfi_offset 5, -8
 1510              		.cfi_offset 14, -4
 1511 0002 8DB0     		sub	sp, sp, #52
 1512              	.LCFI35:
 1513              		.cfi_def_cfa_offset 64
 1514 0004 0446     		mov	r4, r0
 434:mri/core/cmd_vcont.c ****     Action   action;
ARM GAS  /tmp/ccX6djba.s 			page 43


 1515              		.loc 1 434 5 is_stmt 1 view .LVU368
 1516              	.LVL122:
 435:mri/core/cmd_vcont.c **** 
 1517              		.loc 1 435 5 view .LVU369
 437:mri/core/cmd_vcont.c ****     {
 1518              		.loc 1 437 5 view .LVU370
 434:mri/core/cmd_vcont.c ****     Action   action;
 1519              		.loc 1 434 14 is_stmt 0 view .LVU371
 1520 0006 0025     		movs	r5, #0
 437:mri/core/cmd_vcont.c ****     {
 1521              		.loc 1 437 11 view .LVU372
 1522 0008 12E0     		b	.L128
 1523              	.LVL123:
 1524              	.L130:
 439:mri/core/cmd_vcont.c ****         returnValue |= handleActionWithSetThreadState(&action);
 1525              		.loc 1 439 9 is_stmt 1 view .LVU373
 439:mri/core/cmd_vcont.c ****         returnValue |= handleActionWithSetThreadState(&action);
 1526              		.loc 1 439 18 is_stmt 0 view .LVU374
 1527 000a 2146     		mov	r1, r4
 1528 000c 6846     		mov	r0, sp
 1529 000e FFF7FEFF 		bl	parseAction
 1530              	.LVL124:
 1531 0012 0DF11C0E 		add	lr, sp, #28
 1532 0016 EC46     		mov	ip, sp
 1533 0018 BCE80F00 		ldmia	ip!, {r0, r1, r2, r3}
 1534 001c AEE80F00 		stmia	lr!, {r0, r1, r2, r3}
 1535 0020 DCF80030 		ldr	r3, [ip]
 1536 0024 CEF80030 		str	r3, [lr]
 440:mri/core/cmd_vcont.c ****     }
 1537              		.loc 1 440 9 is_stmt 1 view .LVU375
 440:mri/core/cmd_vcont.c ****     }
 1538              		.loc 1 440 24 is_stmt 0 view .LVU376
 1539 0028 07A8     		add	r0, sp, #28
 1540 002a FFF7FEFF 		bl	handleActionWithSetThreadState
 1541              	.LVL125:
 440:mri/core/cmd_vcont.c ****     }
 1542              		.loc 1 440 21 view .LVU377
 1543 002e 0543     		orrs	r5, r5, r0
 1544              	.LVL126:
 1545              	.L128:
 437:mri/core/cmd_vcont.c ****     {
 1546              		.loc 1 437 42 is_stmt 1 view .LVU378
 437:mri/core/cmd_vcont.c ****     {
 1547              		.loc 1 437 12 is_stmt 0 view .LVU379
 1548 0030 2046     		mov	r0, r4
 1549 0032 FFF7FEFF 		bl	mriBuffer_BytesLeft
 1550              	.LVL127:
 437:mri/core/cmd_vcont.c ****     {
 1551              		.loc 1 437 42 view .LVU380
 1552 0036 28B1     		cbz	r0, .L127
 437:mri/core/cmd_vcont.c ****     {
 1553              		.loc 1 437 45 discriminator 1 view .LVU381
 1554 0038 3B21     		movs	r1, #59
 1555 003a 2046     		mov	r0, r4
 1556 003c FFF7FEFF 		bl	mriBuffer_IsNextCharEqualTo
 1557              	.LVL128:
 437:mri/core/cmd_vcont.c ****     {
ARM GAS  /tmp/ccX6djba.s 			page 44


 1558              		.loc 1 437 42 discriminator 1 view .LVU382
 1559 0040 0028     		cmp	r0, #0
 1560 0042 E2D1     		bne	.L130
 1561              	.L127:
 443:mri/core/cmd_vcont.c **** 
 1562              		.loc 1 443 1 view .LVU383
 1563 0044 2846     		mov	r0, r5
 1564 0046 0DB0     		add	sp, sp, #52
 1565              	.LCFI36:
 1566              		.cfi_def_cfa_offset 12
 1567              		@ sp needed
 1568 0048 30BD     		pop	{r4, r5, pc}
 443:mri/core/cmd_vcont.c **** 
 1569              		.loc 1 443 1 view .LVU384
 1570              		.cfi_endproc
 1571              	.LFE23:
 1573              		.section	.text.handleSingleStepAndContinueCommandsWithSetThreadState,"ax",%progbits
 1574              		.align	1
 1575              		.syntax unified
 1576              		.thumb
 1577              		.thumb_func
 1579              	handleSingleStepAndContinueCommandsWithSetThreadState:
 1580              	.LVL129:
 1581              	.LFB21:
 413:mri/core/cmd_vcont.c ****     if (pContinueAction->type != ACTION_NONE || pStepAction->type != ACTION_NONE) {
 1582              		.loc 1 413 1 is_stmt 1 view -0
 1583              		.cfi_startproc
 1584              		@ args = 0, pretend = 0, frame = 0
 1585              		@ frame_needed = 0, uses_anonymous_args = 0
 413:mri/core/cmd_vcont.c ****     if (pContinueAction->type != ACTION_NONE || pStepAction->type != ACTION_NONE) {
 1586              		.loc 1 413 1 is_stmt 0 view .LVU386
 1587 0000 38B5     		push	{r3, r4, r5, lr}
 1588              	.LCFI37:
 1589              		.cfi_def_cfa_offset 16
 1590              		.cfi_offset 3, -16
 1591              		.cfi_offset 4, -12
 1592              		.cfi_offset 5, -8
 1593              		.cfi_offset 14, -4
 1594 0002 0546     		mov	r5, r0
 1595 0004 1446     		mov	r4, r2
 414:mri/core/cmd_vcont.c ****         uint32_t skippedHardcodedBreakpoint = SkipHardcodedBreakpoint();
 1596              		.loc 1 414 5 is_stmt 1 view .LVU387
 414:mri/core/cmd_vcont.c ****         uint32_t skippedHardcodedBreakpoint = SkipHardcodedBreakpoint();
 1597              		.loc 1 414 24 is_stmt 0 view .LVU388
 1598 0006 0B7C     		ldrb	r3, [r1, #16]	@ zero_extendqisi2
 414:mri/core/cmd_vcont.c ****         uint32_t skippedHardcodedBreakpoint = SkipHardcodedBreakpoint();
 1599              		.loc 1 414 8 view .LVU389
 1600 0008 0BB9     		cbnz	r3, .L133
 414:mri/core/cmd_vcont.c ****         uint32_t skippedHardcodedBreakpoint = SkipHardcodedBreakpoint();
 1601              		.loc 1 414 60 discriminator 1 view .LVU390
 1602 000a 137C     		ldrb	r3, [r2, #16]	@ zero_extendqisi2
 414:mri/core/cmd_vcont.c ****         uint32_t skippedHardcodedBreakpoint = SkipHardcodedBreakpoint();
 1603              		.loc 1 414 46 discriminator 1 view .LVU391
 1604 000c 33B1     		cbz	r3, .L134
 1605              	.L133:
 1606              	.LBB44:
 415:mri/core/cmd_vcont.c ****         if (pStepAction->type != ACTION_NONE && justAdvancedPastBreakpoint(skippedHardcodedBreakpoi
ARM GAS  /tmp/ccX6djba.s 			page 45


 1607              		.loc 1 415 9 is_stmt 1 view .LVU392
 415:mri/core/cmd_vcont.c ****         if (pStepAction->type != ACTION_NONE && justAdvancedPastBreakpoint(skippedHardcodedBreakpoi
 1608              		.loc 1 415 47 is_stmt 0 view .LVU393
 1609 000e FFF7FEFF 		bl	mriCmd_SkipHardcodedBreakpoint
 1610              	.LVL130:
 416:mri/core/cmd_vcont.c ****         {
 1611              		.loc 1 416 9 is_stmt 1 view .LVU394
 416:mri/core/cmd_vcont.c ****         {
 1612              		.loc 1 416 24 is_stmt 0 view .LVU395
 1613 0012 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 416:mri/core/cmd_vcont.c ****         {
 1614              		.loc 1 416 12 view .LVU396
 1615 0014 13B1     		cbz	r3, .L134
 416:mri/core/cmd_vcont.c ****         {
 1616              		.loc 1 416 49 discriminator 1 view .LVU397
 1617 0016 FFF7FEFF 		bl	justAdvancedPastBreakpoint
 1618              	.LVL131:
 416:mri/core/cmd_vcont.c ****         {
 1619              		.loc 1 416 46 discriminator 1 view .LVU398
 1620 001a 18B9     		cbnz	r0, .L137
 1621              	.LVL132:
 1622              	.L134:
 416:mri/core/cmd_vcont.c ****         {
 1623              		.loc 1 416 46 discriminator 1 view .LVU399
 1624              	.LBE44:
 424:mri/core/cmd_vcont.c **** }
 1625              		.loc 1 424 5 is_stmt 1 view .LVU400
 424:mri/core/cmd_vcont.c **** }
 1626              		.loc 1 424 12 is_stmt 0 view .LVU401
 1627 001c 2846     		mov	r0, r5
 1628 001e FFF7FEFF 		bl	secondParsePass
 1629              	.LVL133:
 1630              	.L132:
 425:mri/core/cmd_vcont.c **** 
 1631              		.loc 1 425 1 view .LVU402
 1632 0022 38BD     		pop	{r3, r4, r5, pc}
 1633              	.LVL134:
 1634              	.L137:
 1635              	.LBB45:
 420:mri/core/cmd_vcont.c ****         }
 1636              		.loc 1 420 13 is_stmt 1 view .LVU403
 420:mri/core/cmd_vcont.c ****         }
 1637              		.loc 1 420 20 is_stmt 0 view .LVU404
 1638 0024 FFF7FEFF 		bl	mriCmd_Send_T_StopResponse
 1639              	.LVL135:
 1640 0028 FBE7     		b	.L132
 1641              	.LBE45:
 1642              		.cfi_endproc
 1643              	.LFE21:
 1645              		.section	.text.handleAction,"ax",%progbits
 1646              		.align	1
 1647              		.syntax unified
 1648              		.thumb
 1649              		.thumb_func
 1651              	handleAction:
 1652              	.LVL136:
 1653              	.LFB20:
ARM GAS  /tmp/ccX6djba.s 			page 46


 386:mri/core/cmd_vcont.c ****     const   int       noSetPC = 0;
 1654              		.loc 1 386 1 is_stmt 1 view -0
 1655              		.cfi_startproc
 1656              		@ args = 0, pretend = 0, frame = 0
 1657              		@ frame_needed = 0, uses_anonymous_args = 0
 386:mri/core/cmd_vcont.c ****     const   int       noSetPC = 0;
 1658              		.loc 1 386 1 is_stmt 0 view .LVU406
 1659 0000 38B5     		push	{r3, r4, r5, lr}
 1660              	.LCFI38:
 1661              		.cfi_def_cfa_offset 16
 1662              		.cfi_offset 3, -16
 1663              		.cfi_offset 4, -12
 1664              		.cfi_offset 5, -8
 1665              		.cfi_offset 14, -4
 387:mri/core/cmd_vcont.c ****     const   uint32_t  newPC = 0;
 1666              		.loc 1 387 5 is_stmt 1 view .LVU407
 1667              	.LVL137:
 388:mri/core/cmd_vcont.c ****     uint32_t          returnValue = 0;
 1668              		.loc 1 388 5 view .LVU408
 389:mri/core/cmd_vcont.c **** 
 1669              		.loc 1 389 5 view .LVU409
 393:mri/core/cmd_vcont.c ****     {
 1670              		.loc 1 393 5 view .LVU410
 393:mri/core/cmd_vcont.c ****     {
 1671              		.loc 1 393 20 is_stmt 0 view .LVU411
 1672 0002 037C     		ldrb	r3, [r0, #16]	@ zero_extendqisi2
 393:mri/core/cmd_vcont.c ****     {
 1673              		.loc 1 393 5 view .LVU412
 1674 0004 022B     		cmp	r3, #2
 1675 0006 10D0     		beq	.L139
 1676 0008 0446     		mov	r4, r0
 1677 000a 032B     		cmp	r3, #3
 1678 000c 11D0     		beq	.L140
 1679 000e 012B     		cmp	r3, #1
 1680 0010 04D0     		beq	.L144
 405:mri/core/cmd_vcont.c ****             return 0;
 1681              		.loc 1 405 13 is_stmt 1 view .LVU413
 1682 0012 0D48     		ldr	r0, .L145
 1683              	.LVL138:
 405:mri/core/cmd_vcont.c ****             return 0;
 1684              		.loc 1 405 13 is_stmt 0 view .LVU414
 1685 0014 FFF7FEFF 		bl	mriCore_PrepareStringResponse
 1686              	.LVL139:
 406:mri/core/cmd_vcont.c ****    }
 1687              		.loc 1 406 13 is_stmt 1 view .LVU415
 406:mri/core/cmd_vcont.c ****    }
 1688              		.loc 1 406 20 is_stmt 0 view .LVU416
 1689 0018 0025     		movs	r5, #0
 1690 001a 04E0     		b	.L138
 1691              	.LVL140:
 1692              	.L144:
 396:mri/core/cmd_vcont.c ****         case ACTION_SINGLE_STEP:
 1693              		.loc 1 396 13 is_stmt 1 view .LVU417
 396:mri/core/cmd_vcont.c ****         case ACTION_SINGLE_STEP:
 1694              		.loc 1 396 20 is_stmt 0 view .LVU418
 1695 001c 0021     		movs	r1, #0
 1696 001e 0846     		mov	r0, r1
ARM GAS  /tmp/ccX6djba.s 			page 47


 1697              	.LVL141:
 396:mri/core/cmd_vcont.c ****         case ACTION_SINGLE_STEP:
 1698              		.loc 1 396 20 view .LVU419
 1699 0020 FFF7FEFF 		bl	mriCmd_ContinueExecution
 1700              	.LVL142:
 1701 0024 0546     		mov	r5, r0
 1702              	.LVL143:
 1703              	.L138:
 408:mri/core/cmd_vcont.c **** 
 1704              		.loc 1 408 1 view .LVU420
 1705 0026 2846     		mov	r0, r5
 1706 0028 38BD     		pop	{r3, r4, r5, pc}
 1707              	.LVL144:
 1708              	.L139:
 398:mri/core/cmd_vcont.c ****         case ACTION_RANGED_SINGLE_STEP:
 1709              		.loc 1 398 13 is_stmt 1 view .LVU421
 398:mri/core/cmd_vcont.c ****         case ACTION_RANGED_SINGLE_STEP:
 1710              		.loc 1 398 20 is_stmt 0 view .LVU422
 1711 002a FFF7FEFF 		bl	mriCmd_HandleSingleStepCommand
 1712              	.LVL145:
 398:mri/core/cmd_vcont.c ****         case ACTION_RANGED_SINGLE_STEP:
 1713              		.loc 1 398 20 view .LVU423
 1714 002e 0546     		mov	r5, r0
 1715 0030 F9E7     		b	.L138
 1716              	.LVL146:
 1717              	.L140:
 400:mri/core/cmd_vcont.c ****             if (returnValue)
 1718              		.loc 1 400 13 is_stmt 1 view .LVU424
 400:mri/core/cmd_vcont.c ****             if (returnValue)
 1719              		.loc 1 400 27 is_stmt 0 view .LVU425
 1720 0032 FFF7FEFF 		bl	mriCmd_HandleSingleStepCommand
 1721              	.LVL147:
 401:mri/core/cmd_vcont.c ****                 SetSingleSteppingRange(&pAction->range);
 1722              		.loc 1 401 13 is_stmt 1 view .LVU426
 401:mri/core/cmd_vcont.c ****                 SetSingleSteppingRange(&pAction->range);
 1723              		.loc 1 401 16 is_stmt 0 view .LVU427
 1724 0036 0546     		mov	r5, r0
 1725 0038 0028     		cmp	r0, #0
 1726 003a F4D0     		beq	.L138
 402:mri/core/cmd_vcont.c ****             return returnValue;
 1727              		.loc 1 402 17 is_stmt 1 view .LVU428
 1728 003c 04F10800 		add	r0, r4, #8
 1729              	.LVL148:
 402:mri/core/cmd_vcont.c ****             return returnValue;
 1730              		.loc 1 402 17 is_stmt 0 view .LVU429
 1731 0040 FFF7FEFF 		bl	mriCore_SetSingleSteppingRange
 1732              	.LVL149:
 1733 0044 EFE7     		b	.L138
 1734              	.L146:
 1735 0046 00BF     		.align	2
 1736              	.L145:
 1737 0048 00000000 		.word	.LC1
 1738              		.cfi_endproc
 1739              	.LFE20:
 1741              		.section	.text.handleSingleStepAndContinueCommands,"ax",%progbits
 1742              		.align	1
 1743              		.syntax unified
ARM GAS  /tmp/ccX6djba.s 			page 48


 1744              		.thumb
 1745              		.thumb_func
 1747              	handleSingleStepAndContinueCommands:
 1748              	.LVL150:
 1749              	.LFB19:
 374:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 1750              		.loc 1 374 1 is_stmt 1 view -0
 1751              		.cfi_startproc
 1752              		@ args = 0, pretend = 0, frame = 0
 1753              		@ frame_needed = 0, uses_anonymous_args = 0
 374:mri/core/cmd_vcont.c ****     uint32_t returnValue = 0;
 1754              		.loc 1 374 1 is_stmt 0 view .LVU431
 1755 0000 08B5     		push	{r3, lr}
 1756              	.LCFI39:
 1757              		.cfi_def_cfa_offset 8
 1758              		.cfi_offset 3, -8
 1759              		.cfi_offset 14, -4
 375:mri/core/cmd_vcont.c **** 
 1760              		.loc 1 375 5 is_stmt 1 view .LVU432
 1761              	.LVL151:
 377:mri/core/cmd_vcont.c ****         returnValue |= handleAction(pStepAction);
 1762              		.loc 1 377 5 view .LVU433
 377:mri/core/cmd_vcont.c ****         returnValue |= handleAction(pStepAction);
 1763              		.loc 1 377 20 is_stmt 0 view .LVU434
 1764 0002 0B7C     		ldrb	r3, [r1, #16]	@ zero_extendqisi2
 377:mri/core/cmd_vcont.c ****         returnValue |= handleAction(pStepAction);
 1765              		.loc 1 377 8 view .LVU435
 1766 0004 1BB1     		cbz	r3, .L148
 378:mri/core/cmd_vcont.c ****     else
 1767              		.loc 1 378 9 is_stmt 1 view .LVU436
 378:mri/core/cmd_vcont.c ****     else
 1768              		.loc 1 378 24 is_stmt 0 view .LVU437
 1769 0006 0846     		mov	r0, r1
 1770              	.LVL152:
 378:mri/core/cmd_vcont.c ****     else
 1771              		.loc 1 378 24 view .LVU438
 1772 0008 FFF7FEFF 		bl	handleAction
 1773              	.LVL153:
 1774              	.L147:
 383:mri/core/cmd_vcont.c **** 
 1775              		.loc 1 383 1 view .LVU439
 1776 000c 08BD     		pop	{r3, pc}
 1777              	.LVL154:
 1778              	.L148:
 380:mri/core/cmd_vcont.c **** 
 1779              		.loc 1 380 9 is_stmt 1 view .LVU440
 380:mri/core/cmd_vcont.c **** 
 1780              		.loc 1 380 24 is_stmt 0 view .LVU441
 1781 000e FFF7FEFF 		bl	handleAction
 1782              	.LVL155:
 382:mri/core/cmd_vcont.c **** }
 1783              		.loc 1 382 5 is_stmt 1 view .LVU442
 382:mri/core/cmd_vcont.c **** }
 1784              		.loc 1 382 12 is_stmt 0 view .LVU443
 1785 0012 FBE7     		b	.L147
 1786              		.cfi_endproc
 1787              	.LFE19:
ARM GAS  /tmp/ccX6djba.s 			page 49


 1789              		.section	.text.handleVContCommand,"ax",%progbits
 1790              		.align	1
 1791              		.syntax unified
 1792              		.thumb
 1793              		.thumb_func
 1795              	handleVContCommand:
 1796              	.LFB5:
 130:mri/core/cmd_vcont.c ****     Buffer*           pBuffer = GetBuffer();
 1797              		.loc 1 130 1 is_stmt 1 view -0
 1798              		.cfi_startproc
 1799              		@ args = 0, pretend = 0, frame = 56
 1800              		@ frame_needed = 0, uses_anonymous_args = 0
 1801 0000 30B5     		push	{r4, r5, lr}
 1802              	.LCFI40:
 1803              		.cfi_def_cfa_offset 12
 1804              		.cfi_offset 4, -12
 1805              		.cfi_offset 5, -8
 1806              		.cfi_offset 14, -4
 1807 0002 8FB0     		sub	sp, sp, #60
 1808              	.LCFI41:
 1809              		.cfi_def_cfa_offset 72
 131:mri/core/cmd_vcont.c ****     Buffer            replayBuffer = *pBuffer;
 1810              		.loc 1 131 5 view .LVU445
 131:mri/core/cmd_vcont.c ****     Buffer            replayBuffer = *pBuffer;
 1811              		.loc 1 131 33 is_stmt 0 view .LVU446
 1812 0004 FFF7FEFF 		bl	mriCore_GetBuffer
 1813              	.LVL156:
 1814 0008 0446     		mov	r4, r0
 1815              	.LVL157:
 132:mri/core/cmd_vcont.c ****     Action            continueAction;
 1816              		.loc 1 132 5 is_stmt 1 view .LVU447
 132:mri/core/cmd_vcont.c ****     Action            continueAction;
 1817              		.loc 1 132 23 is_stmt 0 view .LVU448
 1818 000a 07C8     		ldm	r0, {r0, r1, r2}
 1819              	.LVL158:
 132:mri/core/cmd_vcont.c ****     Action            continueAction;
 1820              		.loc 1 132 23 view .LVU449
 1821 000c 0EAB     		add	r3, sp, #56
 1822 000e 03E90700 		stmdb	r3, {r0, r1, r2}
 133:mri/core/cmd_vcont.c ****     Action            stepAction;
 1823              		.loc 1 133 5 is_stmt 1 view .LVU450
 134:mri/core/cmd_vcont.c **** 
 1824              		.loc 1 134 5 view .LVU451
 136:mri/core/cmd_vcont.c ****     mri_memset(&stepAction, 0, sizeof(stepAction));
 1825              		.loc 1 136 5 view .LVU452
 1826 0012 1422     		movs	r2, #20
 1827 0014 0021     		movs	r1, #0
 1828 0016 06A8     		add	r0, sp, #24
 1829 0018 FFF7FEFF 		bl	mri_memset
 1830              	.LVL159:
 137:mri/core/cmd_vcont.c **** 
 1831              		.loc 1 137 5 view .LVU453
 1832 001c 1422     		movs	r2, #20
 1833 001e 0021     		movs	r1, #0
 1834 0020 01A8     		add	r0, sp, #4
 1835 0022 FFF7FEFF 		bl	mri_memset
 1836              	.LVL160:
ARM GAS  /tmp/ccX6djba.s 			page 50


 139:mri/core/cmd_vcont.c ****         firstParsePass(pBuffer, &continueAction, &stepAction);
 1837              		.loc 1 139 5 view .LVU454
 139:mri/core/cmd_vcont.c ****         firstParsePass(pBuffer, &continueAction, &stepAction);
 1838              		.loc 1 139 5 view .LVU455
 1839              	.LBB46:
 1840              	.LBI46:
  76:mri/core/try_catch.h **** {
 1841              		.loc 2 76 20 view .LVU456
 1842              	.LBB47:
 1843              		.loc 2 78 5 view .LVU457
 1844              		.loc 2 78 22 is_stmt 0 view .LVU458
 1845 0026 0D4D     		ldr	r5, .L157
 1846 0028 0023     		movs	r3, #0
 1847 002a 2B60     		str	r3, [r5]
 1848              	.LBE47:
 1849              	.LBE46:
 140:mri/core/cmd_vcont.c ****     __catch
 1850              		.loc 1 140 9 is_stmt 1 view .LVU459
 1851 002c 01AA     		add	r2, sp, #4
 1852 002e 06A9     		add	r1, sp, #24
 1853 0030 2046     		mov	r0, r4
 1854 0032 FFF7FEFF 		bl	firstParsePass
 1855              	.LVL161:
 139:mri/core/cmd_vcont.c ****         firstParsePass(pBuffer, &continueAction, &stepAction);
 1856              		.loc 1 139 5 view .LVU460
 141:mri/core/cmd_vcont.c ****         return 0;
 1857              		.loc 1 141 5 view .LVU461
 1858 0036 2B68     		ldr	r3, [r5]
 1859 0038 13B1     		cbz	r3, .L156
 142:mri/core/cmd_vcont.c **** 
 1860              		.loc 1 142 16 is_stmt 0 view .LVU462
 1861 003a 0020     		movs	r0, #0
 1862              	.L151:
 148:mri/core/cmd_vcont.c **** 
 1863              		.loc 1 148 1 view .LVU463
 1864 003c 0FB0     		add	sp, sp, #60
 1865              	.LCFI42:
 1866              		.cfi_remember_state
 1867              		.cfi_def_cfa_offset 12
 1868              		@ sp needed
 1869 003e 30BD     		pop	{r4, r5, pc}
 1870              	.LVL162:
 1871              	.L156:
 1872              	.LCFI43:
 1873              		.cfi_restore_state
 144:mri/core/cmd_vcont.c ****         return handleSingleStepAndContinueCommandsWithSetThreadState(&replayBuffer, &continueAction
 1874              		.loc 1 144 5 is_stmt 1 view .LVU464
 144:mri/core/cmd_vcont.c ****         return handleSingleStepAndContinueCommandsWithSetThreadState(&replayBuffer, &continueAction
 1875              		.loc 1 144 9 is_stmt 0 view .LVU465
 1876 0040 FFF7FEFF 		bl	mriPlatform_RtosIsSetThreadStateSupported
 1877              	.LVL163:
 144:mri/core/cmd_vcont.c ****         return handleSingleStepAndContinueCommandsWithSetThreadState(&replayBuffer, &continueAction
 1878              		.loc 1 144 8 view .LVU466
 1879 0044 28B1     		cbz	r0, .L153
 145:mri/core/cmd_vcont.c ****     else
 1880              		.loc 1 145 9 is_stmt 1 view .LVU467
 145:mri/core/cmd_vcont.c ****     else
ARM GAS  /tmp/ccX6djba.s 			page 51


 1881              		.loc 1 145 16 is_stmt 0 view .LVU468
 1882 0046 01AA     		add	r2, sp, #4
 1883 0048 06A9     		add	r1, sp, #24
 1884 004a 0BA8     		add	r0, sp, #44
 1885 004c FFF7FEFF 		bl	handleSingleStepAndContinueCommandsWithSetThreadState
 1886              	.LVL164:
 1887 0050 F4E7     		b	.L151
 1888              	.L153:
 147:mri/core/cmd_vcont.c **** }
 1889              		.loc 1 147 9 is_stmt 1 view .LVU469
 147:mri/core/cmd_vcont.c **** }
 1890              		.loc 1 147 16 is_stmt 0 view .LVU470
 1891 0052 01A9     		add	r1, sp, #4
 1892 0054 06A8     		add	r0, sp, #24
 1893 0056 FFF7FEFF 		bl	handleSingleStepAndContinueCommands
 1894              	.LVL165:
 1895 005a EFE7     		b	.L151
 1896              	.L158:
 1897              		.align	2
 1898              	.L157:
 1899 005c 00000000 		.word	mriExceptionCode
 1900              		.cfi_endproc
 1901              	.LFE5:
 1903              		.section	.rodata.mriCmd_HandleVContCommands.str1.4,"aMS",%progbits,1
 1904              		.align	2
 1905              	.LC2:
 1906 0000 00       		.ascii	"\000"
 1907              		.section	.text.mriCmd_HandleVContCommands,"ax",%progbits
 1908              		.align	1
 1909              		.global	mriCmd_HandleVContCommands
 1910              		.syntax unified
 1911              		.thumb
 1912              		.thumb_func
 1914              	mriCmd_HandleVContCommands:
 1915              	.LFB3:
  88:mri/core/cmd_vcont.c ****     Buffer*             pBuffer = GetBuffer();
 1916              		.loc 1 88 1 is_stmt 1 view -0
 1917              		.cfi_startproc
 1918              		@ args = 0, pretend = 0, frame = 0
 1919              		@ frame_needed = 0, uses_anonymous_args = 0
 1920 0000 10B5     		push	{r4, lr}
 1921              	.LCFI44:
 1922              		.cfi_def_cfa_offset 8
 1923              		.cfi_offset 4, -8
 1924              		.cfi_offset 14, -4
  89:mri/core/cmd_vcont.c ****     static const char   vContQueryCommand[] = "Cont?";
 1925              		.loc 1 89 5 view .LVU472
  89:mri/core/cmd_vcont.c ****     static const char   vContQueryCommand[] = "Cont?";
 1926              		.loc 1 89 35 is_stmt 0 view .LVU473
 1927 0002 FFF7FEFF 		bl	mriCore_GetBuffer
 1928              	.LVL166:
 1929 0006 0446     		mov	r4, r0
 1930              	.LVL167:
  90:mri/core/cmd_vcont.c ****     static const char   vContCommand[] = "Cont";
 1931              		.loc 1 90 5 is_stmt 1 view .LVU474
  91:mri/core/cmd_vcont.c **** 
 1932              		.loc 1 91 5 view .LVU475
ARM GAS  /tmp/ccX6djba.s 			page 52


  93:mri/core/cmd_vcont.c ****     {
 1933              		.loc 1 93 5 view .LVU476
  93:mri/core/cmd_vcont.c ****     {
 1934              		.loc 1 93 9 is_stmt 0 view .LVU477
 1935 0008 0522     		movs	r2, #5
 1936 000a 0A49     		ldr	r1, .L165
 1937 000c FFF7FEFF 		bl	mriBuffer_MatchesString
 1938              	.LVL168:
  93:mri/core/cmd_vcont.c ****     {
 1939              		.loc 1 93 8 view .LVU478
 1940 0010 40B9     		cbnz	r0, .L164
  97:mri/core/cmd_vcont.c ****     {
 1941              		.loc 1 97 10 is_stmt 1 view .LVU479
  97:mri/core/cmd_vcont.c ****     {
 1942              		.loc 1 97 14 is_stmt 0 view .LVU480
 1943 0012 0422     		movs	r2, #4
 1944 0014 0849     		ldr	r1, .L165+4
 1945 0016 2046     		mov	r0, r4
 1946 0018 FFF7FEFF 		bl	mriBuffer_MatchesString
 1947              	.LVL169:
  97:mri/core/cmd_vcont.c ****     {
 1948              		.loc 1 97 13 view .LVU481
 1949 001c 28B1     		cbz	r0, .L162
  99:mri/core/cmd_vcont.c ****     }
 1950              		.loc 1 99 9 is_stmt 1 view .LVU482
  99:mri/core/cmd_vcont.c ****     }
 1951              		.loc 1 99 16 is_stmt 0 view .LVU483
 1952 001e FFF7FEFF 		bl	handleVContCommand
 1953              	.LVL170:
 1954 0022 01E0     		b	.L159
 1955              	.L164:
  95:mri/core/cmd_vcont.c ****     }
 1956              		.loc 1 95 9 is_stmt 1 view .LVU484
  95:mri/core/cmd_vcont.c ****     }
 1957              		.loc 1 95 16 is_stmt 0 view .LVU485
 1958 0024 FFF7FEFF 		bl	handleVContQueryCommand
 1959              	.LVL171:
 1960              	.L159:
 106:mri/core/cmd_vcont.c **** 
 1961              		.loc 1 106 1 view .LVU486
 1962 0028 10BD     		pop	{r4, pc}
 1963              	.LVL172:
 1964              	.L162:
 103:mri/core/cmd_vcont.c ****         return 0;
 1965              		.loc 1 103 9 is_stmt 1 view .LVU487
 1966 002a 0448     		ldr	r0, .L165+8
 1967 002c FFF7FEFF 		bl	mriCore_PrepareStringResponse
 1968              	.LVL173:
 104:mri/core/cmd_vcont.c ****     }
 1969              		.loc 1 104 9 view .LVU488
 104:mri/core/cmd_vcont.c ****     }
 1970              		.loc 1 104 16 is_stmt 0 view .LVU489
 1971 0030 0020     		movs	r0, #0
 1972 0032 F9E7     		b	.L159
 1973              	.L166:
 1974              		.align	2
 1975              	.L165:
ARM GAS  /tmp/ccX6djba.s 			page 53


 1976 0034 00000000 		.word	vContQueryCommand.2
 1977 0038 00000000 		.word	vContCommand.1
 1978 003c 00000000 		.word	.LC2
 1979              		.cfi_endproc
 1980              	.LFE3:
 1982              		.section	.text.mriCmd_RestoreThreadStates,"ax",%progbits
 1983              		.align	1
 1984              		.global	mriCmd_RestoreThreadStates
 1985              		.syntax unified
 1986              		.thumb
 1987              		.thumb_func
 1989              	mriCmd_RestoreThreadStates:
 1990              	.LFB26:
 490:mri/core/cmd_vcont.c **** 
 491:mri/core/cmd_vcont.c **** 
 492:mri/core/cmd_vcont.c **** void RestoreThreadStates(void)
 493:mri/core/cmd_vcont.c **** {
 1991              		.loc 1 493 1 is_stmt 1 view -0
 1992              		.cfi_startproc
 1993              		@ args = 0, pretend = 0, frame = 0
 1994              		@ frame_needed = 0, uses_anonymous_args = 0
 1995 0000 08B5     		push	{r3, lr}
 1996              	.LCFI45:
 1997              		.cfi_def_cfa_offset 8
 1998              		.cfi_offset 3, -8
 1999              		.cfi_offset 14, -4
 494:mri/core/cmd_vcont.c ****     if (!Platform_RtosIsSetThreadStateSupported())
 2000              		.loc 1 494 5 view .LVU491
 2001              		.loc 1 494 10 is_stmt 0 view .LVU492
 2002 0002 FFF7FEFF 		bl	mriPlatform_RtosIsSetThreadStateSupported
 2003              	.LVL174:
 2004              		.loc 1 494 8 view .LVU493
 2005 0006 00B9     		cbnz	r0, .L170
 2006              	.L167:
 495:mri/core/cmd_vcont.c ****         return;
 496:mri/core/cmd_vcont.c ****     Platform_RtosRestorePrevThreadState();
 497:mri/core/cmd_vcont.c **** }
 2007              		.loc 1 497 1 view .LVU494
 2008 0008 08BD     		pop	{r3, pc}
 2009              	.L170:
 496:mri/core/cmd_vcont.c **** }
 2010              		.loc 1 496 5 is_stmt 1 view .LVU495
 2011 000a FFF7FEFF 		bl	mriPlatform_RtosRestorePrevThreadState
 2012              	.LVL175:
 2013 000e FBE7     		b	.L167
 2014              		.cfi_endproc
 2015              	.LFE26:
 2017              		.section	.rodata.negativeOne.0,"a"
 2018              		.align	2
 2021              	negativeOne.0:
 2022 0000 2D3100   		.ascii	"-1\000"
 2023              		.section	.rodata.vContCommand.1,"a"
 2024              		.align	2
 2027              	vContCommand.1:
 2028 0000 436F6E74 		.ascii	"Cont\000"
 2028      00
 2029              		.section	.rodata.vContQueryCommand.2,"a"
ARM GAS  /tmp/ccX6djba.s 			page 54


 2030              		.align	2
 2033              	vContQueryCommand.2:
 2034 0000 436F6E74 		.ascii	"Cont?\000"
 2034      3F00
 2035              		.text
 2036              	.Letext0:
 2037              		.file 3 "/usr/lib/gcc/arm-none-eabi/12.2.0/include/stddef.h"
 2038              		.file 4 "/usr/arm-none-eabi/include/machine/_default_types.h"
 2039              		.file 5 "/usr/arm-none-eabi/include/sys/_stdint.h"
 2040              		.file 6 "mri/core/buffer.h"
 2041              		.file 7 "mri/core/core.h"
 2042              		.file 8 "mri/core/platforms.h"
 2043              		.file 9 "mri/core/cmd_step.h"
 2044              		.file 10 "mri/core/cmd_registers.h"
 2045              		.file 11 "mri/core/cmd_continue.h"
 2046              		.file 12 "mri/core/cmd_common.h"
 2047              		.file 13 "mri/core/libc.h"
ARM GAS  /tmp/ccX6djba.s 			page 55


DEFINED SYMBOLS
                            *ABS*:0000000000000000 cmd_vcont.c
     /tmp/ccX6djba.s:21     .text.justAdvancedPastBreakpoint:0000000000000000 $t
     /tmp/ccX6djba.s:26     .text.justAdvancedPastBreakpoint:0000000000000000 justAdvancedPastBreakpoint
     /tmp/ccX6djba.s:44     .text.getThreadIdFromAction:0000000000000000 $t
     /tmp/ccX6djba.s:49     .text.getThreadIdFromAction:0000000000000000 getThreadIdFromAction
     /tmp/ccX6djba.s:98     .rodata.handleVContQueryCommand.str1.4:0000000000000000 $d
     /tmp/ccX6djba.s:102    .text.handleVContQueryCommand:0000000000000000 $t
     /tmp/ccX6djba.s:107    .text.handleVContQueryCommand:0000000000000000 handleVContQueryCommand
     /tmp/ccX6djba.s:133    .text.handleVContQueryCommand:0000000000000010 $d
     /tmp/ccX6djba.s:138    .text.parseOptionalThreadId:0000000000000000 $t
     /tmp/ccX6djba.s:143    .text.parseOptionalThreadId:0000000000000000 parseOptionalThreadId
     /tmp/ccX6djba.s:240    .text.parseOptionalThreadId:0000000000000050 $d
     /tmp/ccX6djba.s:2021   .rodata.negativeOne.0:0000000000000000 negativeOne.0
     /tmp/ccX6djba.s:246    .text.parseContinueAction:0000000000000000 $t
     /tmp/ccX6djba.s:251    .text.parseContinueAction:0000000000000000 parseContinueAction
     /tmp/ccX6djba.s:302    .text.parseSingleStepAction:0000000000000000 $t
     /tmp/ccX6djba.s:307    .text.parseSingleStepAction:0000000000000000 parseSingleStepAction
     /tmp/ccX6djba.s:358    .text.parseContinueWithSignalAction:0000000000000000 $t
     /tmp/ccX6djba.s:363    .text.parseContinueWithSignalAction:0000000000000000 parseContinueWithSignalAction
     /tmp/ccX6djba.s:442    .text.parseContinueWithSignalAction:0000000000000040 $d
     /tmp/ccX6djba.s:447    .text.parseSingleStepWithSignalAction:0000000000000000 $t
     /tmp/ccX6djba.s:452    .text.parseSingleStepWithSignalAction:0000000000000000 parseSingleStepWithSignalAction
     /tmp/ccX6djba.s:531    .text.parseSingleStepWithSignalAction:0000000000000040 $d
     /tmp/ccX6djba.s:536    .text.parseAddressRange:0000000000000000 $t
     /tmp/ccX6djba.s:541    .text.parseAddressRange:0000000000000000 parseAddressRange
     /tmp/ccX6djba.s:616    .text.parseAddressRange:0000000000000038 $d
     /tmp/ccX6djba.s:621    .text.parseRangedSingleStepAction:0000000000000000 $t
     /tmp/ccX6djba.s:626    .text.parseRangedSingleStepAction:0000000000000000 parseRangedSingleStepAction
     /tmp/ccX6djba.s:716    .text.parseRangedSingleStepAction:0000000000000050 $d
     /tmp/ccX6djba.s:721    .text.parseAction:0000000000000000 $t
     /tmp/ccX6djba.s:726    .text.parseAction:0000000000000000 parseAction
     /tmp/ccX6djba.s:862    .text.parseAction:0000000000000080 $d
     /tmp/ccX6djba.s:867    .text.isActionSpecificToNonHaltedThreadId:0000000000000000 $t
     /tmp/ccX6djba.s:872    .text.isActionSpecificToNonHaltedThreadId:0000000000000000 isActionSpecificToNonHaltedThreadId
     /tmp/ccX6djba.s:918    .text.isActionSpecificToHaltedThreadId:0000000000000000 $t
     /tmp/ccX6djba.s:923    .text.isActionSpecificToHaltedThreadId:0000000000000000 isActionSpecificToHaltedThreadId
     /tmp/ccX6djba.s:969    .text.getActionPriority:0000000000000000 $t
     /tmp/ccX6djba.s:974    .text.getActionPriority:0000000000000000 getActionPriority
     /tmp/ccX6djba.s:1079   .text.isActionMoreSpecificThanCurrent:0000000000000000 $t
     /tmp/ccX6djba.s:1084   .text.isActionMoreSpecificThanCurrent:0000000000000000 isActionMoreSpecificThanCurrent
     /tmp/ccX6djba.s:1128   .rodata.firstParsePass.str1.4:0000000000000000 $d
     /tmp/ccX6djba.s:1132   .text.firstParsePass:0000000000000000 $t
     /tmp/ccX6djba.s:1137   .text.firstParsePass:0000000000000000 firstParsePass
     /tmp/ccX6djba.s:1395   .text.firstParsePass:000000000000011c $d
     /tmp/ccX6djba.s:1401   .text.handleActionWithSetThreadState:0000000000000000 $t
     /tmp/ccX6djba.s:1406   .text.handleActionWithSetThreadState:0000000000000000 handleActionWithSetThreadState
     /tmp/ccX6djba.s:1492   .text.secondParsePass:0000000000000000 $t
     /tmp/ccX6djba.s:1497   .text.secondParsePass:0000000000000000 secondParsePass
     /tmp/ccX6djba.s:1574   .text.handleSingleStepAndContinueCommandsWithSetThreadState:0000000000000000 $t
     /tmp/ccX6djba.s:1579   .text.handleSingleStepAndContinueCommandsWithSetThreadState:0000000000000000 handleSingleStepAndContinueCommandsWithSetThreadState
     /tmp/ccX6djba.s:1646   .text.handleAction:0000000000000000 $t
     /tmp/ccX6djba.s:1651   .text.handleAction:0000000000000000 handleAction
     /tmp/ccX6djba.s:1737   .text.handleAction:0000000000000048 $d
     /tmp/ccX6djba.s:1742   .text.handleSingleStepAndContinueCommands:0000000000000000 $t
     /tmp/ccX6djba.s:1747   .text.handleSingleStepAndContinueCommands:0000000000000000 handleSingleStepAndContinueCommands
     /tmp/ccX6djba.s:1790   .text.handleVContCommand:0000000000000000 $t
ARM GAS  /tmp/ccX6djba.s 			page 56


     /tmp/ccX6djba.s:1795   .text.handleVContCommand:0000000000000000 handleVContCommand
     /tmp/ccX6djba.s:1899   .text.handleVContCommand:000000000000005c $d
     /tmp/ccX6djba.s:1904   .rodata.mriCmd_HandleVContCommands.str1.4:0000000000000000 $d
     /tmp/ccX6djba.s:1908   .text.mriCmd_HandleVContCommands:0000000000000000 $t
     /tmp/ccX6djba.s:1914   .text.mriCmd_HandleVContCommands:0000000000000000 mriCmd_HandleVContCommands
     /tmp/ccX6djba.s:1976   .text.mriCmd_HandleVContCommands:0000000000000034 $d
     /tmp/ccX6djba.s:2033   .rodata.vContQueryCommand.2:0000000000000000 vContQueryCommand.2
     /tmp/ccX6djba.s:2027   .rodata.vContCommand.1:0000000000000000 vContCommand.1
     /tmp/ccX6djba.s:1983   .text.mriCmd_RestoreThreadStates:0000000000000000 $t
     /tmp/ccX6djba.s:1989   .text.mriCmd_RestoreThreadStates:0000000000000000 mriCmd_RestoreThreadStates
     /tmp/ccX6djba.s:2018   .rodata.negativeOne.0:0000000000000000 $d
     /tmp/ccX6djba.s:2024   .rodata.vContCommand.1:0000000000000000 $d
     /tmp/ccX6djba.s:2030   .rodata.vContQueryCommand.2:0000000000000000 $d

UNDEFINED SYMBOLS
mriCore_GetInitializedBuffer
mriBuffer_WriteString
mriBuffer_BytesLeft
mriBuffer_IsNextCharEqualTo
mriBuffer_MatchesString
mriBuffer_ReadUIntegerAsHex
mriExceptionCode
mriBuffer_ReadByteAsHex
mriCmd_ThrowIfNextCharIsNotEqualTo
mriBuffer_ReadChar
mri_memset
mriPlatform_RtosGetHaltedThreadId
mriPlatform_RtosIsSetThreadStateSupported
mriCore_PrepareStringResponse
mriPlatform_RtosSetThreadState
mriPlatform_EnableSingleStep
mriCore_SetSingleSteppingRange
mriCmd_SkipHardcodedBreakpoint
mriCmd_Send_T_StopResponse
mriCmd_ContinueExecution
mriCmd_HandleSingleStepCommand
mriCore_GetBuffer
mriPlatform_RtosRestorePrevThreadState
